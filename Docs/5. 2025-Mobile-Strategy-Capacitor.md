# DooDates - Stratégie Mobile avec Capacitor

## Vue d'ensemble

**Objectif :** Transformer l'application web DooDates en application Android native en réutilisant 100% du code React existant via Capacitor.

**Principe :** Un seul codebase pour web, PWA et mobile natif.

**Architecture :** Backend-first avec logique métier centralisée dans Supabase Edge Functions.

---

## 1. Architecture Technique

### 1.1 Stack Technologique
```
┌─────────────────────────────────────────────────────────┐
│              BACKEND (Supabase)                        │
│  ┌──────────────────────────────────────────────────┐  │
│  │  Edge Functions (Logique Métier)                 │  │
│  │  - poll-management (CRUD polls)                   │  │
│  │  - vote-management (CRUD votes)                  │  │
│  │  - notification-service (push/email)             │  │
│  │  - analytics-aggregation (stats)                 │  │
│  │  - quota-tracking (déjà existant)                │  │
│  └──────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────┐  │
│  │  Database (PostgreSQL)                           │  │
│  │  - Tables: polls, votes, conversations, etc.     │  │
│  │  - RLS Policies (sécurité)                       │  │
│  │  - Functions SQL (validations)                   │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                        ↕ API REST
┌─────────────────────────────────────────────────────────┐
│              CLIENTS (React Apps)                       │
│  ├── Web → Vercel (production)                        │
│  ├── PWA → Service Worker (existant)                  │
│  └── Mobile → Capacitor → Android APK                │
│                                                         │
│  Code commun minimal :                                 │
│  - UI Components (React)                               │
│  - API Client (appels Edge Functions)                  │
│  - State Management (React Query/SWR)                 │
│  - Native Bridge (Capacitor plugins uniquement)       │
└─────────────────────────────────────────────────────────┘
```

### 1.2 Principes d'Architecture Backend-First

**Maximiser Backend :**
- ✅ Toute la logique métier dans Edge Functions
- ✅ Validations côté serveur (Zod schemas)
- ✅ Calculs et agrégations (stats, analytics)
- ✅ Gestion des notifications (push/email)
- ✅ Quotas et limites
- ✅ Génération de slugs, tokens admin
- ✅ Business rules (expiration, permissions)

**Minimiser Apps :**
- ✅ UI uniquement (composants React)
- ✅ Appels API simples (fetch vers Edge Functions)
- ✅ Cache local (React Query)
- ✅ Gestion d'état UI (React state)
- ✅ Adaptations natives (Capacitor plugins)

**Code Commun :**
- ✅ Types TypeScript partagés (via npm package ou monorepo)
- ✅ API Client unifié (`lib/api-client.ts`)
- ✅ Hooks React réutilisables (`hooks/usePolls.ts`)
- ✅ Composants UI identiques (web/mobile)

### 1.3 Avantages Capacitor + Backend-First
- **Réutilisation complète** du code React/TypeScript existant
- **Maintenance unifiée** : un bug fixé = fixé partout
- **Logique centralisée** : un seul endroit pour la business logic
- **Sécurité renforcée** : validations serveur obligatoires
- **Performance** : WebView optimisé avec accès natif
- **Déploiement rapide** : 1-2 semaines vs 2-3 mois Flutter
- **Évolutivité** : ajout iOS/autres plateformes sans duplication

---

## 2. Architecture Backend Détaillée

### 2.1 Edge Functions - Logique Métier Centralisée

#### `poll-management` - Gestion Complète des Sondages
```typescript
// supabase/functions/poll-management/index.ts
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { z } from "https://deno.land/x/zod@v3.22.4/mod.ts";

// Schema de validation (backend uniquement)
const CreatePollSchema = z.object({
  type: z.enum(["date", "form"]),
  title: z.string().min(1).max(200),
  description: z.string().max(1000).optional(),
  // ... autres champs
});

serve(async (req) => {
  const { endpoint, data } = await req.json();
  
  switch (endpoint) {
    case "create":
      // ✅ Validation backend
      const validated = CreatePollSchema.parse(data);
      
      // ✅ Génération slug backend
      const slug = generateSlug(validated.title);
      
      // ✅ Vérification quotas backend
      await checkQuota(userId, "poll_created");
      
      // ✅ Création dans DB
      const poll = await createPollInDB(validated, slug);
      
      // ✅ Consommation quota backend
      await consumeQuota(userId, "poll_created", 1);
      
      return new Response(JSON.stringify({ poll }));
      
    case "update":
      // ✅ Validation + permissions backend
      // ✅ Business rules (expiration, etc.)
      
    case "delete":
      // ✅ Soft delete + cascade backend
      
    case "list":
      // ✅ Filtrage + pagination backend
      // ✅ RLS policies appliquées
  }
});
```

**Responsabilités Backend :**
- ✅ Validation complète des données (Zod)
- ✅ Génération de slugs uniques
- ✅ Gestion des quotas
- ✅ Business rules (expiration, permissions)
- ✅ Optimisations DB (indexes, queries)

**Client (Apps) :**
```typescript
// src/lib/api-client.ts (CODE COMMUN)
export async function createPoll(pollData: PollData) {
  return callSupabaseEdgeFunction("poll-management", {
    endpoint: "create",
    data: pollData
  });
}
```

#### `vote-management` - Gestion des Votes
```typescript
// supabase/functions/vote-management/index.ts
serve(async (req) => {
  const { endpoint, pollSlug, voteData } = await req.json();
  
  switch (endpoint) {
    case "submit":
      // ✅ Validation vote backend
      // ✅ Vérification poll actif/expiré
      // ✅ Calcul agrégations temps réel
      // ✅ Mise à jour stats poll
      
    case "update":
      // ✅ Permissions (votant ou créateur)
      
    case "delete":
      // ✅ Soft delete + recalcul stats
  }
});
```

#### `notification-service` - Notifications Centralisées
```typescript
// supabase/functions/notification-service/index.ts
serve(async (req) => {
  const { endpoint, pollId, type } = await req.json();
  
  switch (endpoint) {
    case "sendInvitations":
      // ✅ Envoi emails backend (Resend/SendGrid)
      // ✅ Gestion templates
      // ✅ Rate limiting
      
    case "scheduleReminders":
      // ✅ Planification cron backend
      // ✅ Push notifications (FCM/APNS)
      
    case "sendPush":
      // ✅ Push natif backend
      // ✅ Fallback email si push échoue
  }
});
```

#### `analytics-aggregation` - Calculs et Stats
```typescript
// supabase/functions/analytics-aggregation/index.ts
serve(async (req) => {
  const { endpoint, pollId } = await req.json();
  
  switch (endpoint) {
    case "getStats":
      // ✅ Calcul agrégations backend (SQL)
      // ✅ Cache Redis si nécessaire
      // ✅ Optimisation requêtes lourdes
      
    case "getBestSlots":
      // ✅ Algorithme optimisation backend
      // ✅ Calcul scores créneaux
  }
});
```

### 2.2 Database Functions - Validations SQL

```sql
-- Fonctions SQL pour validations complexes
CREATE OR REPLACE FUNCTION validate_poll_dates(
  p_dates jsonb,
  p_time_slots jsonb
) RETURNS boolean AS $$
  -- Validation dates futures
  -- Validation créneaux cohérents
  -- Validation limites (max 30 dates)
$$ LANGUAGE plpgsql;

-- Triggers automatiques
CREATE TRIGGER update_poll_stats
  AFTER INSERT OR UPDATE OR DELETE ON votes
  FOR EACH ROW
  EXECUTE FUNCTION recalculate_poll_stats();
```

### 2.3 API Client Unifié (Code Commun)

```typescript
// src/lib/api-client.ts (UTILISÉ PAR WEB + MOBILE)
import { callSupabaseEdgeFunction } from "./supabaseApi";

export class ApiClient {
  // Polls
  static async createPoll(data: PollData) {
    return callSupabaseEdgeFunction("poll-management", {
      endpoint: "create",
      data
    });
  }
  
  static async getPoll(slug: string) {
    return callSupabaseEdgeFunction("poll-management", {
      endpoint: "get",
      slug
    });
  }
  
  // Votes
  static async submitVote(pollSlug: string, voteData: VoteData) {
    return callSupabaseEdgeFunction("vote-management", {
      endpoint: "submit",
      pollSlug,
      voteData
    });
  }
  
  // Notifications
  static async sendInvitations(pollId: string, emails: string[]) {
    return callSupabaseEdgeFunction("notification-service", {
      endpoint: "sendInvitations",
      pollId,
      emails
    });
  }
}
```

### 2.4 Hooks React Réutilisables (Code Commun)

```typescript
// src/hooks/usePolls.ts (UTILISÉ PAR WEB + MOBILE)
export function usePolls() {
  const createPoll = useCallback(async (pollData: PollData) => {
    // ✅ Appel API simple (pas de logique métier)
    const result = await ApiClient.createPoll(pollData);
    
    // ✅ Gestion cache React Query
    queryClient.invalidateQueries(["polls"]);
    
    return result;
  }, []);
  
  // ... autres méthodes similaires
}
```

### 2.5 Avantages Architecture Backend-First

**Sécurité :**
- ✅ Validations serveur obligatoires (impossible de bypass)
- ✅ RLS policies appliquées automatiquement
- ✅ Rate limiting centralisé
- ✅ Quotas vérifiés côté serveur

**Performance :**
- ✅ Calculs lourds côté serveur (pas de charge client)
- ✅ Cache Redis pour stats fréquentes
- ✅ Optimisations DB centralisées
- ✅ Bundle client réduit (moins de code)

**Maintenance :**
- ✅ Un seul endroit pour business logic
- ✅ Tests backend isolés
- ✅ Déploiements indépendants
- ✅ Debugging simplifié

**Évolutivité :**
- ✅ Ajout iOS sans duplication logique
- ✅ API réutilisable (webhooks, intégrations)
- ✅ Scaling backend indépendant
- ✅ Migration future facilitée

---

## 3. Plan d'Implémentation

### Phase 0 : Migration Backend-First (Prérequis)

**Objectif :** Déplacer la logique métier actuelle vers Edge Functions avant d'ajouter mobile.

#### 3.0.1 Création Edge Functions
```bash
# Créer les Edge Functions principales
supabase functions new poll-management
supabase functions new vote-management
supabase functions new notification-service
supabase functions new analytics-aggregation
```

#### 3.0.2 Migration Logique Métier
- ✅ Extraire validation depuis `usePolls.ts` → Edge Function
- ✅ Déplacer génération slug → Backend
- ✅ Déplacer gestion quotas → Backend (déjà fait)
- ✅ Déplacer calculs stats → Backend
- ✅ Créer API Client unifié (`lib/api-client.ts`)

#### 3.0.3 Tests Backend
- ✅ Tests unitaires Edge Functions (Deno)
- ✅ Tests d'intégration API
- ✅ Validation schémas Zod

**Durée estimée :** 1-2 semaines

---

### Phase 1 : Setup Initial Capacitor (Semaine 1)

#### 3.1 Installation Capacitor
```bash
# Installation des dépendances
npm install @capacitor/core @capacitor/cli @capacitor/android

# Configuration projet
npx cap init DooDates app.doodates.com
npx cap add android

# Premier build
npm run build
npx cap copy
npx cap open android
```

#### 3.2 Configuration Android
```typescript
// capacitor.config.ts
import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'app.doodates.com',
  appName: 'DooDates',
  webDir: 'dist',
  server: {
    androidScheme: 'https'
  },
  plugins: {
    SplashScreen: {
      launchShowDuration: 2000,
      backgroundColor: "#3b82f6",
      showSpinner: false
    },
    PushNotifications: {
      presentationOptions: ["badge", "sound", "alert"]
    }
  }
};

export default config;
```

### Phase 2 : Optimisations Mobile (Semaine 2)

#### 3.2.1 Adaptations UI Spécifiques
```typescript
// hooks/useCapacitor.ts
import { Capacitor } from '@capacitor/core';

export const useCapacitor = () => {
  const isNative = Capacitor.isNativePlatform();
  const platform = Capacitor.getPlatform();
  
  return {
    isNative,
    isAndroid: platform === 'android',
    isIOS: platform === 'ios',
    isWeb: platform === 'web'
  };
};

// Adaptations conditionnelles
const { isNative } = useCapacitor();

return (
  <div className={`
    ${isNative ? 'pt-safe-area-top pb-safe-area-bottom' : ''}
    ${isNative ? 'select-none' : ''}
  `}>
    {/* Interface adaptée */}
  </div>
);
```

#### 3.2.2 APIs Natives Intégrées
```typescript
// services/native.ts
import { Camera, CameraResultType } from '@capacitor/camera';
import { LocalNotifications } from '@capacitor/local-notifications';
import { Share } from '@capacitor/share';

export class NativeService {
  // Partage natif
  static async shareUrl(url: string, title: string) {
    if (Capacitor.isNativePlatform()) {
      await Share.share({
        title,
        url,
        dialogTitle: 'Partager le sondage'
      });
    } else {
      // Fallback web
      navigator.share({ title, url });
    }
  }

  // Notifications locales
  static async scheduleNotification(poll: Poll) {
    await LocalNotifications.schedule({
      notifications: [{
        title: 'Rappel sondage',
        body: `N'oubliez pas de voter pour "${poll.title}"`,
        id: poll.id,
        schedule: { at: new Date(poll.reminder_date) }
      }]
    });
  }
}
```

### Phase 3 : Fonctionnalités Avancées (Semaine 3-4)

#### 3.3.1 Notifications Push (Backend-First)

**Client (Code Commun) :** Enregistrement token uniquement
```typescript
// src/lib/push-token.ts (CODE COMMUN)
import { PushNotifications } from '@capacitor/push-notifications';
import { ApiClient } from './api-client';

export class PushTokenService {
  static async register() {
    // Demande permission
    const permission = await PushNotifications.requestPermissions();
    
    if (permission.receive === 'granted') {
      await PushNotifications.register();
    }

    // Envoyer token au backend
    PushNotifications.addListener('registration', async (token) => {
      await ApiClient.registerPushToken(token.value);
    });

    // Réception notifications (affichage uniquement)
    PushNotifications.addListener('pushNotificationReceived', (notification) => {
      toast.success(notification.body);
    });
  }
}
```

**Backend :** Envoi notifications centralisé
```typescript
// supabase/functions/notification-service/index.ts
serve(async (req) => {
  const { endpoint, pollId, type } = await req.json();
  
  switch (endpoint) {
    case "sendPush":
      // ✅ Récupération tokens depuis DB
      const tokens = await getPushTokensForPoll(pollId);
      
      // ✅ Envoi via FCM/APNS backend
      await sendPushNotifications(tokens, {
        title: "Nouveau vote",
        body: "Quelqu'un a voté sur votre sondage"
      });
      
      // ✅ Fallback email si push échoue
      await sendEmailFallback(pollId);
  }
});
```

#### 3.3.2 Intégration Calendrier Natif (Client uniquement)
```typescript
// services/calendar.ts
import { Calendar } from '@capacitor-community/calendar';

export class CalendarService {
  static async addPollToCalendar(poll: Poll, selectedSlot: TimeSlot) {
    if (Capacitor.isNativePlatform()) {
      await Calendar.createEvent({
        title: poll.title,
        location: poll.location || '',
        startDate: selectedSlot.start,
        endDate: selectedSlot.end,
        notes: `Créé via DooDates: ${poll.url}`
      });
    }
  }
}
```

---

## 4. Prototype Parallèle (Sans Casser l'App)

### 4.1 Objectif Prototype

Valider l'architecture backend-first et Capacitor **en parallèle** de l'application existante, sans impact sur le code de production.

### 4.2 Stratégie : Feature Flag + Code Parallèle

**Principe :** 
- ✅ Nouvelle Edge Function `poll-management-v2` (ne remplace pas l'ancien)
- ✅ Nouveau client API `api-client-v2.ts` (coexiste avec l'ancien)
- ✅ Activation via feature flag (localStorage ou env variable)
- ✅ Application existante continue de fonctionner normalement

### 4.3 Implémentation Prototype

#### 4.3.1 Backend : Edge Function Parallèle

```bash
# Créer nouvelle Edge Function (ne touche pas aux existantes)
supabase functions new poll-management-v2
```

```typescript
// supabase/functions/poll-management-v2/index.ts
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { z } from "https://deno.land/x/zod@v3.22.4/mod.ts";

// Schema validation backend
const CreatePollSchema = z.object({
  type: z.enum(["date", "form"]),
  title: z.string().min(1).max(200),
  description: z.string().max(1000).optional(),
  selectedDates: z.array(z.string()).optional(),
  timeSlotsByDate: z.record(z.array(z.any())).optional(),
  questions: z.array(z.any()).optional(),
  settings: z.object({
    timeGranularity: z.number().optional(),
    allowAnonymousVotes: z.boolean().optional(),
    allowMaybeVotes: z.boolean().optional(),
    sendNotifications: z.boolean().optional(),
    expiresAt: z.string().optional(),
  }).optional(),
});

serve(async (req) => {
  const { endpoint, data } = await req.json();
  
  if (endpoint === "create") {
    // ✅ Validation backend
    const validated = CreatePollSchema.parse(data);
    
    // ✅ Génération slug backend
    const slug = generateSlug(validated.title);
    
    // ✅ Vérification quotas (utilise fonction existante)
    const supabase = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
    );
    
    const authHeader = req.headers.get("authorization");
    if (authHeader) {
      const token = authHeader.replace("Bearer ", "");
      const { data: { user } } = await supabase.auth.getUser(token);
      
      if (user) {
        // Vérifier quota via Edge Function existante
        const quotaCheck = await fetch(
          `${Deno.env.get("SUPABASE_URL")!}/functions/v1/quota-tracking`,
          {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${token}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              endpoint: "checkQuota",
              action: "poll_created",
              credits: 1,
            }),
          }
        );
        
        const quotaResult = await quotaCheck.json();
        if (!quotaResult.allowed) {
          return new Response(
            JSON.stringify({ error: "Quota limit reached" }),
            { status: 403 }
          );
        }
      }
    }
    
    // ✅ Création dans DB (même table que l'ancien système)
    const pollData = {
      id: crypto.randomUUID(),
      creator_id: user?.id || null,
      title: validated.title,
      description: validated.description || null,
      slug,
      type: validated.type,
      settings: validated.settings || {},
      status: "active",
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    
    const { data: poll, error } = await supabase
      .from("polls") // ou "conversations" selon votre architecture
      .insert(pollData)
      .select()
      .single();
    
    if (error) {
      return new Response(
        JSON.stringify({ error: error.message }),
        { status: 500 }
      );
    }
    
    // ✅ Consommer quota si utilisateur connecté
    if (user && authHeader) {
      await fetch(
        `${Deno.env.get("SUPABASE_URL")!}/functions/v1/quota-tracking`,
        {
          method: "POST",
          headers: {
            "Authorization": authHeader,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            endpoint: "consumeCredits",
            action: "poll_created",
            credits: 1,
          }),
        }
      );
    }
    
    return new Response(JSON.stringify({ poll }), {
      headers: { "Content-Type": "application/json" },
    });
  }
  
  return new Response(
    JSON.stringify({ error: "Endpoint not implemented in prototype" }),
    { status: 404 }
  );
});

function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "") + "-" + Date.now().toString(36);
}
```

#### 4.3.2 Client : API Client Parallèle

```typescript
// src/lib/api-client-v2.ts (NOUVEAU - coexiste avec l'ancien)
import { callSupabaseEdgeFunction } from "./supabaseApi";

export class ApiClientV2 {
  static async createPoll(pollData: PollData) {
    return callSupabaseEdgeFunction("poll-management-v2", {
      endpoint: "create",
      data: pollData,
    });
  }
  
  // Autres méthodes à ajouter progressivement...
}
```

#### 4.3.3 Hook : Feature Flag pour Basculer

```typescript
// src/hooks/usePolls.ts (MODIFIER - ajouter flag)
export function usePolls() {
  // ✅ Feature flag pour activer prototype backend-first
  const useBackendFirst = useMemo(() => {
    if (typeof window === "undefined") return false;
    
    // Activation via localStorage (pour tests)
    if (localStorage.getItem("use-backend-first") === "1") {
      return true;
    }
    
    // Ou via variable d'environnement (pour déploiement)
    return import.meta.env.VITE_USE_BACKEND_FIRST === "true";
  }, []);

  const createPoll = useCallback(
    async (pollData: PollData): Promise<{ poll?: StoragePoll; error?: string }> => {
      // ✅ Basculer vers nouveau système si flag activé
      if (useBackendFirst) {
        try {
          const result = await ApiClientV2.createPoll(pollData);
          return { poll: result.poll };
        } catch (error) {
          return { error: error.message };
        }
      }
      
      // ✅ Sinon, utiliser l'ancien système (code existant inchangé)
      // ... code existant de createPoll ...
    },
    [useBackendFirst]
  );
  
  // ... reste du code inchangé ...
}
```

#### 4.3.4 Activation Prototype

**Option 1 : localStorage (pour développement)**
```typescript
// Dans la console navigateur ou un composant admin
localStorage.setItem("use-backend-first", "1");
// Recharger la page
```

**Option 2 : Variable d'environnement (pour déploiement)**
```bash
# .env.local
VITE_USE_BACKEND_FIRST=true
```

**Option 3 : UI Toggle (pour tests utilisateurs)**
```typescript
// src/components/DevTools.tsx (optionnel)
export function DevTools() {
  const [useBackendFirst, setUseBackendFirst] = useState(
    () => localStorage.getItem("use-backend-first") === "1"
  );
  
  return (
    <div className="fixed bottom-4 right-4 bg-gray-800 text-white p-4 rounded">
      <label>
        <input
          type="checkbox"
          checked={useBackendFirst}
          onChange={(e) => {
            const value = e.target.checked ? "1" : "0";
            localStorage.setItem("use-backend-first", value);
            setUseBackendFirst(e.target.checked);
            window.location.reload();
          }}
        />
        Use Backend-First (Prototype)
      </label>
    </div>
  );
}
```

### 4.4 Structure Prototype (Sans Casser l'Existant)

```
DooDates/
├── supabase/functions/
│   ├── poll-management-v2/     # ✅ NOUVEAU (prototype)
│   │   └── index.ts
│   ├── quota-tracking/          # ✅ EXISTANT (utilisé par v2)
│   └── ... (autres fonctions existantes)
│
├── src/
│   ├── lib/
│   │   ├── api-client-v2.ts    # ✅ NOUVEAU (prototype)
│   │   └── supabaseApi.ts      # ✅ EXISTANT (utilisé par v2)
│   │
│   ├── hooks/
│   │   └── usePolls.ts         # ✅ MODIFIÉ (ajout flag)
│   │
│   └── components/
│       └── PollCreator.tsx      # ✅ INCHANGÉ (utilise hook)
│
└── android/                     # ✅ NOUVEAU (Capacitor)
```

### 4.5 Avantages de cette Approche

**Sécurité :**
- ✅ Application existante continue de fonctionner
- ✅ Rollback instantané (désactiver flag)
- ✅ Tests A/B possibles (activer pour certains utilisateurs)

**Développement :**
- ✅ Pas de merge conflicts avec code existant
- ✅ Tests isolés du prototype
- ✅ Déploiement progressif possible

**Migration :**
- ✅ Migration progressive fonction par fonction
- ✅ Validation avant remplacement complet
- ✅ Comparaison performances ancien vs nouveau

### 4.6 Plan de Test Prototype

**Phase 1 : Backend uniquement (Jour 1-2)**
1. Créer Edge Function `poll-management-v2`
2. Tester avec curl/Postman
3. Valider création poll dans DB

**Phase 2 : Client web (Jour 3)**
1. Créer `api-client-v2.ts`
2. Ajouter flag dans `usePolls.ts`
3. Tester création poll avec flag activé
4. Comparer avec ancien système

**Phase 3 : Mobile (Jour 4-5)**
1. Setup Capacitor
2. Build Android
3. Tester création poll depuis Android avec flag activé

**Phase 4 : Validation (Jour 5)**
1. Tests de charge (nouveau vs ancien)
2. Tests de régression (ancien système toujours OK)
3. Documentation résultats

### 4.7 Critères de Validation

**Fonctionnel :**
- ✅ Création poll fonctionne avec nouveau système
- ✅ Ancien système toujours fonctionnel
- ✅ Pas de régression dans l'app existante

**Technique :**
- ✅ Logique métier uniquement dans Edge Function
- ✅ Code client minimal (UI + appels API)
- ✅ Pas de duplication logique

**Performance :**
- ✅ Temps de réponse comparable ou meilleur
- ✅ Bundle size réduit (moins de code client)

**Durée estimée :** 3-5 jours

### 4.8 Guide de Démarrage Rapide Prototype

**Étape 1 : Créer Edge Function**
```bash
cd DooDates
supabase functions new poll-management-v2
# Copier le code de la section 4.3.1 dans le fichier créé
```

**Étape 2 : Déployer Edge Function**
```bash
supabase functions deploy poll-management-v2
```

**Étape 3 : Créer API Client V2**
```bash
# Créer src/lib/api-client-v2.ts avec le code de la section 4.3.2
```

**Étape 4 : Modifier usePolls.ts**
```typescript
// Ajouter le feature flag (section 4.3.3)
// Importer ApiClientV2
```

**Étape 5 : Tester**
```bash
# Dans la console navigateur
localStorage.setItem("use-backend-first", "1");
# Recharger la page
# Créer un poll → devrait utiliser le nouveau système
```

**Étape 6 : Désactiver si problème**
```bash
# Dans la console navigateur
localStorage.removeItem("use-backend-first");
# Recharger → retour à l'ancien système
```

---

## 5. Workflow de Déploiement Edge Functions

### 5.1 Cycle de Vie : Du Code à la Production

```
┌─────────────────────────────────────────────────────────┐
│  1. DÉVELOPPEMENT LOCAL                                  │
│  ┌───────────────────────────────────────────────────┐  │
│  │  Écrire code dans                                  │  │
│  │  supabase/functions/poll-management-v2/index.ts    │  │
│  └───────────────────────────────────────────────────┘  │
│                        ↓                                 │
│  ┌───────────────────────────────────────────────────┐  │
│  │  Tester localement avec Supabase CLI              │  │
│  │  supabase functions serve poll-management-v2     │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│  2. DÉPLOIEMENT                                          │
│  ┌───────────────────────────────────────────────────┐  │
│  │  Déployer vers Supabase                           │  │
│  │  supabase functions deploy poll-management-v2     │  │
│  └───────────────────────────────────────────────────┘  │
│                        ↓                                 │
│  ┌───────────────────────────────────────────────────┐  │
│  │  Fonction disponible immédiatement sur :          │  │
│  │  https://[project].supabase.co/functions/v1/...    │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│  3. UTILISATION                                          │
│  ┌───────────────────────────────────────────────────┐  │
│  │  Client appelle la fonction depuis le code       │  │
│  │  callSupabaseEdgeFunction("poll-management-v2") │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 5.2 Étapes Détaillées de Déploiement

#### 5.2.1 Prérequis

**1. Installer Supabase CLI** (si pas déjà fait)
```bash
# Windows (via winget)
winget install Supabase.CLI

# Ou via npm (local au projet)
npm install -D supabase
```

**2. Authentifier avec Supabase**
```bash
# Via CLI global
supabase login

# Ou via npm local
npx supabase login
# ou
npm run supabase:login
```

**3. Lier au projet Supabase**
```bash
# Récupérer le project-ref depuis le dashboard Supabase
# URL: https://supabase.com/dashboard/project/[project-ref]

npx supabase link --project-ref [votre-project-ref]
# ou
npm run supabase:link -- --project-ref [votre-project-ref]
```

#### 5.2.2 Développement Local (Optionnel mais Recommandé)

**Tester la fonction localement avant déploiement :**

```bash
# Démarrer Supabase local (Docker requis)
npx supabase start

# Servir la fonction localement
npx supabase functions serve poll-management-v2

# La fonction sera disponible sur :
# http://localhost:54321/functions/v1/poll-management-v2
```

**Tester avec curl :**
```bash
curl -X POST http://localhost:54321/functions/v1/poll-management-v2 \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer [votre-token]" \
  -d '{"endpoint": "create", "data": {...}}'
```

#### 5.2.3 Déploiement vers Production

**Déployer une fonction spécifique :**
```bash
# Déployer poll-management-v2
npx supabase functions deploy poll-management-v2

# Ou avec npm script (si configuré)
npm run supabase:deploy -- poll-management-v2
```

**Déployer toutes les fonctions :**
```bash
npx supabase functions deploy
```

**Après déploiement :**
- ✅ La fonction est **immédiatement disponible** en production
- ✅ URL : `https://[project-ref].supabase.co/functions/v1/poll-management-v2`
- ✅ Pas de redémarrage nécessaire
- ✅ Les clients peuvent l'utiliser tout de suite

#### 5.2.4 Vérification Post-Déploiement

**1. Vérifier dans le Dashboard Supabase :**
- Aller sur : https://supabase.com/dashboard/project/[project-ref]/functions
- La fonction `poll-management-v2` doit apparaître avec statut "Active"

**2. Tester avec curl :**
```bash
curl -X POST https://[project-ref].supabase.co/functions/v1/poll-management-v2 \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer [votre-token]" \
  -H "apikey: [votre-anon-key]" \
  -d '{"endpoint": "create", "data": {...}}'
```

**3. Tester depuis l'app :**
```typescript
// Activer le flag prototype
localStorage.setItem("use-backend-first", "1");

// Créer un poll → devrait utiliser la nouvelle Edge Function
```

### 5.3 Scripts NPM Recommandés

Ajouter dans `package.json` :

```json
{
  "scripts": {
    "supabase:login": "supabase login",
    "supabase:link": "supabase link",
    "supabase:functions:serve": "supabase functions serve",
    "supabase:functions:deploy": "supabase functions deploy",
    "supabase:functions:deploy:v2": "supabase functions deploy poll-management-v2",
    "supabase:functions:logs": "supabase functions logs poll-management-v2"
  }
}
```

### 5.4 Workflow Complet Exemple

**Scénario : Créer et déployer `poll-management-v2`**

```bash
# 1. Créer la fonction
npx supabase functions new poll-management-v2

# 2. Écrire le code
# Éditer supabase/functions/poll-management-v2/index.ts

# 3. Tester localement (optionnel)
npx supabase start
npx supabase functions serve poll-management-v2
# Tester avec curl ou Postman

# 4. Déployer
npx supabase functions deploy poll-management-v2

# 5. Vérifier les logs
npx supabase functions logs poll-management-v2

# 6. Tester en production
# Activer flag dans l'app : localStorage.setItem("use-backend-first", "1")
```

### 5.5 Gestion des Versions et Rollback

**Supabase ne gère pas de versions multiples** d'une même fonction. Chaque déploiement **remplace** la version précédente.

**Stratégie de rollback :**
1. **Git comme source de vérité** : Toujours commit avant déploiement
2. **Rollback via Git** :
   ```bash
   # Revenir à une version précédente
   git checkout [commit-hash] -- supabase/functions/poll-management-v2/
   
   # Re-déployer
   npx supabase functions deploy poll-management-v2
   ```

**Pour le prototype :**
- Utiliser un nom différent (`poll-management-v2`) permet de garder l'ancien système intact
- Pas besoin de rollback : désactiver le flag suffit

### 5.6 Logs et Debugging

**Voir les logs en temps réel :**
```bash
npx supabase functions logs poll-management-v2 --follow
```

**Voir les logs dans le Dashboard :**
- Aller sur : Dashboard → Edge Functions → poll-management-v2 → Logs
- Filtres disponibles : niveau (error, warn, info), période

**Debugging :**
```typescript
// Dans votre Edge Function
console.log("Debug info", { data, userId });
console.error("Error occurred", error);

// Les logs apparaissent dans :
// - CLI : supabase functions logs
// - Dashboard : Edge Functions → Logs
```

### 5.7 Variables d'Environnement

**Secrets Supabase (pour API keys, etc.) :**
```bash
# Définir un secret
npx supabase secrets set RESEND_API_KEY=your-key-here

# Lister les secrets
npx supabase secrets list

# Utiliser dans la fonction
const apiKey = Deno.env.get("RESEND_API_KEY");
```

**Variables d'environnement par fonction :**
- Les secrets sont **partagés** entre toutes les fonctions
- Utiliser des préfixes pour éviter les conflits : `POLL_MANAGEMENT_RESEND_KEY`

### 5.8 CI/CD avec GitHub Actions (Optionnel)

```yaml
# .github/workflows/deploy-edge-functions.yml
name: Deploy Edge Functions

on:
  push:
    branches: [main]
    paths:
      - 'supabase/functions/**'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest
      
      - name: Deploy Edge Functions
        run: |
          supabase functions deploy poll-management-v2
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
```

### 5.9 Checklist Déploiement

**Avant de déployer :**
- [ ] Code testé localement (si possible)
- [ ] Code commité dans Git
- [ ] Variables d'environnement configurées (secrets)
- [ ] Authentification Supabase CLI (`supabase login`)
- [ ] Projet lié (`supabase link`)

**Pendant le déploiement :**
- [ ] Exécuter `supabase functions deploy [nom-fonction]`
- [ ] Vérifier que le déploiement réussit (pas d'erreurs)

**Après déploiement :**
- [ ] Vérifier dans le Dashboard Supabase (fonction active)
- [ ] Tester avec curl/Postman
- [ ] Tester depuis l'app (avec flag activé)
- [ ] Vérifier les logs (pas d'erreurs)

---

## 6. Workflow de Développement

### 6.1 Structure Projet
```
DooDates/
├── src/                    # Code React (inchangé)
├── dist/                   # Build web
├── android/                # Projet Android généré
├── capacitor.config.ts     # Configuration Capacitor
└── package.json           # Dépendances mises à jour
```

### 6.2 Scripts NPM
```json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:android": "npm run build && npx cap copy android",
    "android:dev": "npx cap run android",
    "android:build": "npx cap build android",
    "android:open": "npx cap open android"
  }
}
```

### 6.3 Workflow GitHub Actions
```yaml
# .github/workflows/android-build.yml
name: Android Build
on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '17'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build web app
        run: npm run build
      
      - name: Build Android
        run: |
          npx cap copy android
          npx cap build android --prod
      
      - name: Upload APK
        uses: actions/upload-artifact@v3
        with:
          name: app-release.apk
          path: android/app/build/outputs/apk/release/
```

---

## 7. Tests et Développement Mobile

### 7.1 Vue d'Ensemble : Options de Test

```
┌─────────────────────────────────────────────────────────┐
│  OPTIONS DE TEST MOBILE                                 │
│                                                          │
│  1. ÉMULATEURS/SIMULATEURS (Gratuits)                  │
│     ├── Android Studio (Android)                        │
│     └── Xcode Simulator (iOS - macOS uniquement)        │
│                                                          │
│  2. APPAREILS PHYSIQUES (Recommandé)                   │
│     ├── USB Debugging (Android)                         │
│     └── USB/WiFi Debugging (iOS)                        │
│                                                          │
│  3. SERVICES CLOUD (CI/CD)                             │
│     ├── Firebase Test Lab                              │
│     ├── BrowserStack                                    │
│     └── Sauce Labs                                      │
└─────────────────────────────────────────────────────────┘
```

### 7.2 Android : Émulateur Android Studio

#### 7.2.1 Installation et Configuration

**1. Installer Android Studio**
- Télécharger : https://developer.android.com/studio
- Installer avec Android SDK et Android Virtual Device (AVD)

**2. Créer un Émulateur Android**
```bash
# Via Android Studio UI (recommandé)
# Tools → Device Manager → Create Device
# Choisir un device (ex: Pixel 5)
# Choisir une image système (ex: Android 13 - API 33)

# Ou via ligne de commande
avdmanager create avd -n Pixel5_API33 -k "system-images;android-33;google_apis;x86_64"
```

**3. Lister les émulateurs disponibles**
```bash
emulator -list-avds
# Output: Pixel5_API33
```

#### 7.2.2 Lancer l'Émulateur

**Option 1 : Via Android Studio**
- Device Manager → Cliquer sur ▶️ Play

**Option 2 : Via ligne de commande**
```bash
# Lancer un émulateur spécifique
emulator -avd Pixel5_API33

# Lancer en arrière-plan (pour CI/CD)
emulator -avd Pixel5_API33 -no-window &
```

**Option 3 : Via Capacitor CLI**
```bash
# Capacitor lance automatiquement l'émulateur si disponible
npx cap run android

# Ou spécifier un device
npx cap run android --target Pixel5_API33
```

#### 7.2.3 Développement avec Hot Reload

**Workflow recommandé :**
```bash
# Terminal 1 : Lancer l'émulateur
emulator -avd Pixel5_API33

# Terminal 2 : Build et déployer
npm run build
npx cap copy android
npx cap run android

# Pour hot reload (modifications web)
npm run dev
# Dans Android Studio : Run → Apply Changes
```

**Hot Reload automatique :**
```bash
# Capacitor peut surveiller les changements
npx cap run android --livereload --external
```

#### 7.2.4 Debugging Android

**Chrome DevTools (Recommandé)**
```bash
# 1. Lancer l'app sur l'émulateur
npx cap run android

# 2. Ouvrir Chrome et aller sur :
chrome://inspect

# 3. Cliquer sur "inspect" sous votre device
# → DevTools s'ouvre avec console, network, etc.
```

**Android Studio Debugger**
- Ouvrir `android/` dans Android Studio
- Run → Debug 'app'
- Breakpoints dans le code Java/Kotlin natif

**Logs Android (logcat)**
```bash
# Voir tous les logs
adb logcat

# Filtrer par tag
adb logcat -s Capacitor:V CapacitorConsole:V

# Filtrer par niveau
adb logcat *:E  # Erreurs uniquement
```

### 7.3 iOS : Simulateur Xcode (macOS uniquement)

#### 7.3.1 Prérequis

**⚠️ Important :** Le simulateur iOS nécessite macOS et Xcode.

**Installation :**
```bash
# Installer Xcode depuis App Store (gratuit mais volumineux ~15GB)
# Ou installer uniquement les command line tools :
xcode-select --install
```

#### 7.3.2 Créer et Lancer le Simulateur

**1. Lister les simulateurs disponibles**
```bash
xcrun simctl list devices
```

**2. Lancer un simulateur spécifique**
```bash
# Lancer iPhone 14 Pro
xcrun simctl boot "iPhone 14 Pro"

# Ouvrir Simulator.app
open -a Simulator
```

**3. Via Capacitor CLI**
```bash
# Capacitor détecte automatiquement le simulateur
npx cap run ios

# Ou spécifier un device
npx cap run ios --target "iPhone 14 Pro"
```

#### 7.3.3 Développement avec Hot Reload

**Workflow recommandé :**
```bash
# Terminal 1 : Build web
npm run build

# Terminal 2 : Copier et ouvrir Xcode
npx cap copy ios
npx cap open ios

# Dans Xcode :
# 1. Sélectionner un simulateur (ex: iPhone 14 Pro)
# 2. Cliquer sur ▶️ Run
# 3. Pour hot reload : Product → Apply Changes
```

**Hot Reload automatique :**
```bash
# Capacitor peut surveiller les changements
npx cap run ios --livereload --external
```

#### 7.3.4 Debugging iOS

**Safari Web Inspector**
```bash
# 1. Lancer l'app sur le simulateur
npx cap run ios

# 2. Dans Safari : Develop → [Device] → [App]
# → Web Inspector s'ouvre avec console, network, etc.
```

**Xcode Debugger**
- Breakpoints dans le code Swift/Objective-C natif
- Console intégrée dans Xcode

**Logs iOS**
```bash
# Voir les logs du simulateur
xcrun simctl spawn booted log stream --level=debug

# Ou dans Xcode : View → Debug Area → Show Debug Area
```

### 7.4 Appareils Physiques

#### 7.4.1 Android (USB Debugging)

**1. Activer le mode développeur**
- Paramètres → À propos du téléphone → Appuyer 7 fois sur "Numéro de build"
- Paramètres → Options développeur → Activer "Débogage USB"

**2. Connecter l'appareil**
```bash
# Vérifier que l'appareil est détecté
adb devices
# Output: List of devices attached
#         ABC123XYZ    device

# Si "unauthorized" : Autoriser sur le téléphone
```

**3. Déployer sur l'appareil**
```bash
# Capacitor détecte automatiquement l'appareil connecté
npx cap run android

# Ou spécifier l'appareil
npx cap run android --target ABC123XYZ
```

#### 7.4.2 iOS (USB/WiFi Debugging)

**1. Prérequis**
- Compte développeur Apple (gratuit pour développement)
- Certificat de développement signé dans Xcode

**2. Connecter l'appareil**
- Connecter via USB
- Dans Xcode : Window → Devices and Simulators
- Faire confiance à l'ordinateur sur l'iPhone

**3. Déployer sur l'appareil**
```bash
# Dans Xcode, sélectionner l'appareil physique
# Cliquer sur ▶️ Run
```

**WiFi Debugging (iOS 9+)**
- Connecter une fois via USB
- Activer "Connect via network" dans Xcode
- Débrancher USB → Débogage WiFi actif

### 7.5 Workflow de Test dans Cursor

#### 7.5.1 Configuration Recommandée

**Structure de fenêtres :**
```
┌──────────────┬──────────────────┬──────────────┐
│   Cursor     │   Terminal 1     │   Terminal 2 │
│   (Code)     │   (Build)        │   (Emulator) │
├──────────────┼──────────────────┼──────────────┤
│  - Éditer    │  npm run build   │  emulator    │
│  - Debug     │  npx cap copy    │  -avd ...    │
│  - Git       │  npx cap run     │              │
└──────────────┴──────────────────┴──────────────┘
```

#### 7.5.2 Scripts NPM pour Faciliter les Tests

```json
{
  "scripts": {
    "android:emulator": "emulator -avd Pixel5_API33",
    "android:dev": "npm run build && npx cap copy android && npx cap run android",
    "android:dev:watch": "npm run dev & npx cap run android --livereload --external",
    "android:log": "adb logcat -s Capacitor:V CapacitorConsole:V",
    "ios:simulator": "xcrun simctl boot 'iPhone 14 Pro' && open -a Simulator",
    "ios:dev": "npm run build && npx cap copy ios && npx cap open ios",
    "ios:log": "xcrun simctl spawn booted log stream"
  }
}
```

#### 7.5.3 Hot Reload dans Cursor

**Option 1 : Watch Mode**
```bash
# Terminal dans Cursor
npm run dev  # Vite watch mode

# Dans Android Studio / Xcode
# Run → Apply Changes (après chaque modification)
```

**Option 2 : Capacitor Live Reload**
```bash
# Démarrer avec live reload
npx cap run android --livereload --external

# Modifier le code React → Recharge automatique
```

**Option 3 : Extension Cursor (si disponible)**
- Certaines extensions permettent de lancer directement depuis Cursor
- Vérifier les extensions "Android" ou "iOS" dans le marketplace

### 7.6 Tests Automatisés (E2E)

#### 7.6.1 Appium (Cross-platform)

```typescript
// tests/e2e/mobile.spec.ts
import { remote } from 'webdriverio';

describe('Mobile E2E Tests', () => {
  let driver: WebdriverIO.Browser;

  beforeAll(async () => {
    driver = await remote({
      platformName: 'Android',
      deviceName: 'Pixel5_API33',
      app: './android/app/build/outputs/apk/debug/app-debug.apk',
      automationName: 'UiAutomator2'
    });
  });

  it('should create a poll', async () => {
    await driver.$('~create-poll-button').click();
    // ... tests
  });
});
```

#### 7.6.2 Capacitor E2E Plugin

```typescript
// Utiliser Playwright avec Capacitor
import { test } from '@playwright/test';

test('Mobile test', async ({ page }) => {
  // Capacitor expose les mêmes APIs que le web
  await page.goto('capacitor://localhost');
  // ... tests
});
```

### 7.7 Services Cloud (CI/CD)

#### 7.7.1 Firebase Test Lab

```yaml
# .github/workflows/mobile-tests.yml
name: Mobile E2E Tests

on: [push]

jobs:
  android-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
      
      - name: Build APK
        run: |
          npm ci
          npm run build
          npx cap copy android
          cd android && ./gradlew assembleDebug
      
      - name: Run Firebase Test Lab
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          firebaseServiceAccount: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
          projectId: your-project-id
          testLab: true
```

#### 7.7.2 BrowserStack / Sauce Labs

- Services payants mais puissants
- Accès à de vrais appareils physiques
- Intégration avec CI/CD facile

### 7.8 Checklist Setup Mobile

**Android :**
- [ ] Android Studio installé
- [ ] Android SDK configuré
- [ ] Émulateur créé et testé
- [ ] `adb` dans le PATH
- [ ] Capacitor Android ajouté (`npx cap add android`)

**iOS (macOS uniquement) :**
- [ ] Xcode installé
- [ ] Xcode Command Line Tools installés
- [ ] Simulateur iOS testé
- [ ] Compte développeur Apple configuré
- [ ] Capacitor iOS ajouté (`npx cap add ios`)

**Appareils Physiques :**
- [ ] Mode développeur activé (Android)
- [ ] USB Debugging activé (Android)
- [ ] Appareil détecté (`adb devices`)
- [ ] Certificat de développement (iOS)

### 7.9 Commandes Rapides de Référence

```bash
# Android
emulator -list-avds                    # Lister émulateurs
emulator -avd Pixel5_API33             # Lancer émulateur
adb devices                            # Lister appareils connectés
adb logcat                             # Voir logs
npx cap run android                    # Build + Run

# iOS (macOS)
xcrun simctl list devices              # Lister simulateurs
xcrun simctl boot "iPhone 14 Pro"     # Lancer simulateur
npx cap run ios                        # Build + Run
npx cap open ios                       # Ouvrir dans Xcode
```

---

## 8. Optimisations Spécifiques

### 8.1 Performance Mobile
```typescript
// Lazy loading adaptatif
const PollCreator = lazy(() => 
  import('./components/PollCreator').then(module => ({
    default: module.PollCreator
  }))
);

// Gestion mémoire
useEffect(() => {
  if (Capacitor.isNativePlatform()) {
    // Nettoyage agressif sur mobile
    return () => {
      // Cleanup listeners
    };
  }
}, []);
```

### 6.2 Gestion Offline (Backend-First)

**Stratégie :** Sync queue côté client, traitement backend.

```typescript
// src/lib/offline-sync.ts (CODE COMMUN)
export class OfflineSync {
  // Queue locale (localStorage ou SQLite)
  static async queueAction(action: 'createPoll' | 'submitVote', data: unknown) {
    const queue = await this.getQueue();
    queue.push({ action, data, timestamp: Date.now() });
    await this.saveQueue(queue);
  }
  
  // Sync automatique quand online
  static async syncWhenOnline() {
    const queue = await this.getQueue();
    for (const item of queue) {
      try {
        await ApiClient[item.action](item.data);
        await this.removeFromQueue(item);
      } catch (error) {
        // Retry plus tard
      }
    }
  }
}

// Edge Function gère les conflits backend
// supabase/functions/poll-management/index.ts
// - Vérification timestamps
// - Résolution conflits
// - Retour erreur si nécessaire
```

---

## 7. Timeline et Ressources

### 7.1 Planning Détaillé

**Phase 0 : Migration Backend-First (1-2 semaines)**
- Semaine 1 : Création Edge Functions + migration logique métier
- Semaine 2 : Tests backend + refactoring client

**Phase 1 : Setup Capacitor (Semaine 3)**
- Jour 1-2 : Installation + premier build Android
- Jour 3-5 : Tests + adaptations UI mobile

**Phase 2 : Optimisations (Semaine 4)**
- APIs natives + notifications backend
- Gestion offline avec sync queue

**Phase 3 : Finalisation (Semaine 5)**
- Optimisations + tests complets
- Documentation

**Phase 4 : Déploiement (Semaine 6)**
- Soumission Play Store
- Monitoring + feedback

### 7.2 Ressources Nécessaires
- **Android Studio** : Pour build et debug
- **Compte Google Play** : 25$ one-time fee
- **Certificat de signature** : Génération automatique
- **Device Android** : Pour tests réels

### 7.3 Maintenance
- **Builds automatiques** : GitHub Actions
- **Tests** : Même suite que web + tests natifs
- **Déploiement** : Play Store via fastlane

---

## 8. Avantages Concurrentiels

### 8.1 vs Doodle/Framadate
- **App native** : Doodle n'a qu'une PWA basique
- **Notifications push** : Rappels automatiques
- **Intégration calendrier** : Ajout direct des événements
- **Offline** : Création brouillons hors ligne

### 8.2 Métriques Attendues
- **Engagement** : +40% vs web (notifications)
- **Rétention** : +25% (app installée)
- **Conversion** : +15% (UX native)
- **Temps de développement** : 4 semaines vs 12 semaines Flutter

---

## 9. Risques et Mitigation

### 9.1 Risques Identifiés
- **Performance WebView** : Tests sur devices bas de gamme
- **Taille APK** : Optimisation bundle (tree-shaking)
- **APIs manquantes** : Plugins communauté disponibles

### 9.2 Plan B
- Si problèmes majeurs Capacitor → Migration Flutter
- Code React reste utilisable comme référence UI
- Base Supabase compatible Flutter

---

## Conclusion

Capacitor offre le meilleur compromis pour DooDates :
- **Rapidité** : App Android en 1 mois
- **Maintenance** : Codebase unique
- **Fonctionnalités** : APIs natives complètes
- **Évolutivité** : Migration Flutter possible

**Prochaine étape :** 
1. **Option Prototype** : Valider architecture backend-first (3-5 jours)
2. **Option Directe** : Migration backend complète puis Capacitor (6 semaines)

---

## 10. Checklist Migration Backend-First

### 10.1 Backend (Edge Functions)
- [ ] Créer `poll-management` Edge Function
- [ ] Créer `vote-management` Edge Function  
- [ ] Créer `notification-service` Edge Function
- [ ] Créer `analytics-aggregation` Edge Function
- [ ] Migrer validation Zod depuis client
- [ ] Migrer génération slug backend
- [ ] Migrer calculs stats backend
- [ ] Tests unitaires Edge Functions

### 10.2 Client (Code Commun)
- [ ] Créer `lib/api-client.ts` unifié
- [ ] Refactorer `hooks/usePolls.ts` (appels API uniquement)
- [ ] Supprimer logique métier des composants
- [ ] Ajouter gestion erreurs API
- [ ] Tests intégration API

### 10.3 Mobile (Capacitor)
- [ ] Installation Capacitor
- [ ] Configuration Android
- [ ] Tests build Android
- [ ] Adaptations UI mobile
- [ ] Intégration plugins natifs
