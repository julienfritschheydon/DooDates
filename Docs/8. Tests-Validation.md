# DooDates - Tests et Validation

**Document créé le 23 juin 2025**

## Vue d'Ensemble

### Stratégie de Test - Mobile-First
Approche complète couvrant mobile, frontend, backend, et intégration. **Priorité sur l'expérience mobile**.

### Pyramide de Tests Mobile-First
```
Mobile E2E Tests (15%) - PRIORITÉ
├── Playwright Mobile
├── Scénarios tactiles complets
├── Tests multi-devices/navigateurs
└── Performance mobile

Integration Tests (25%)
├── API endpoints mobile-optimisés
├── Database operations
├── Real-time basique
└── PWA features

Unit Tests (40%) - Mobile Components
├── Components React Mobile
├── Touch/Gesture handlers
├── Mobile utility functions
└── Business logic mobile

Mobile UX Tests (20%) - NOUVEAU
├── Touch target sizes
├── Gesture recognition
├── Performance mobile
└── Accessibility mobile
```

---

## Tests Unitaires

### Frontend (React + Vitest)

#### Configuration Vitest
```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    globals: true,
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.d.ts',
        '**/*.config.*'
      ]
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
});
```

#### Tests Composants
```typescript
// src/components/__tests__/PollCreator.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { PollCreator } from '../PollCreator';

const mockLocalStorage = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn()
};

Object.defineProperty(window, 'localStorage', {
  value: mockLocalStorage
});

describe('PollCreator', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockLocalStorage.getItem.mockReturnValue(null);
  });

  it('should render calendar with current month', () => {
    render(<PollCreator />);
    
    const currentMonth = new Date().toLocaleString('fr', { month: 'long' });
    expect(screen.getByText(new RegExp(currentMonth, 'i'))).toBeInTheDocument();
  });

  it('should select dates when clicked', async () => {
    const user = userEvent.setup();
    render(<PollCreator />);
    
    // Sélectionner une date future
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const dateButton = screen.getByTestId(`date-${tomorrow.toISOString().split('T')[0]}`);
    
    await user.click(dateButton);
    
    expect(dateButton).toHaveClass('bg-blue-500');
    expect(mockLocalStorage.setItem).toHaveBeenCalledWith(
      'pollCreator',
      expect.stringContaining(tomorrow.toISOString().split('T')[0])
    );
  });

  it('should show time slots when horaires button is clicked', async () => {
    const user = userEvent.setup();
    render(<PollCreator />);
    
    // Sélectionner une date d'abord
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const dateButton = screen.getByTestId(`date-${tomorrow.toISOString().split('T')[0]}`);
    await user.click(dateButton);
    
    // Cliquer sur le bouton horaires
    const horaireButton = screen.getByTestId('show-timeslots');
    await user.click(horaireButton);
    
    expect(screen.getByTestId('timeslots-grid')).toBeInTheDocument();
    expect(screen.getByText('14:00')).toBeInTheDocument();
  });

  it('should validate email format', async () => {
    const user = userEvent.setup();
    render(<PollCreator />);
    
    // Naviguer vers la section partage
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    await user.click(screen.getByTestId(`date-${tomorrow.toISOString().split('T')[0]}`));
    await user.click(screen.getByTestId('show-share'));
    
    // Entrer un email invalide
    const emailInput = screen.getByTestId('participant-emails');
    await user.type(emailInput, 'invalid-email');
    
    await waitFor(() => {
      expect(screen.getByText(/format d'email invalide/i)).toBeInTheDocument();
    });
  });

  it('should save state to localStorage on changes', async () => {
    const user = userEvent.setup();
    render(<PollCreator />);
    
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    await user.click(screen.getByTestId(`date-${tomorrow.toISOString().split('T')[0]}`));
    
    expect(mockLocalStorage.setItem).toHaveBeenCalledWith(
      'pollCreator',
      expect.any(String)
    );
  });
});
```

#### Tests Hooks
```typescript
// src/hooks/__tests__/usePollCreator.test.ts
import { describe, it, expect, vi } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { usePollCreator } from '../usePollCreator';

describe('usePollCreator', () => {
  it('should initialize with default state', () => {
    const { result } = renderHook(() => usePollCreator());
    
    expect(result.current.selectedDates).toEqual([]);
    expect(result.current.showTimeSlots).toBe(false);
    expect(result.current.pollTitle).toBe('');
  });

  it('should add date when selectDate is called', () => {
    const { result } = renderHook(() => usePollCreator());
    
    act(() => {
      result.current.selectDate('2025-07-01');
    });
    
    expect(result.current.selectedDates).toContain('2025-07-01');
  });

  it('should remove date when already selected', () => {
    const { result } = renderHook(() => usePollCreator());
    
    act(() => {
      result.current.selectDate('2025-07-01');
      result.current.selectDate('2025-07-01'); // Toggle off
    });
    
    expect(result.current.selectedDates).not.toContain('2025-07-01');
  });

  it('should validate email format', () => {
    const { result } = renderHook(() => usePollCreator());
    
    act(() => {
      result.current.setParticipantEmails('invalid-email, valid@example.com');
    });
    
    expect(result.current.emailErrors).toContain('invalid-email');
    expect(result.current.emailErrors).not.toContain('valid@example.com');
  });
});
```

### Backend (Node.js + Jest)

#### Tests API Endpoints
```typescript
// tests/api/polls.test.ts
import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import request from 'supertest';
import { app } from '../../src/app';
import { supabase } from '../../src/lib/supabase';

describe('Polls API', () => {
  let authToken: string;
  let testUserId: string;

  beforeEach(async () => {
    // Setup test user
    const { data: authData } = await supabase.auth.signUp({
      email: 'test@example.com',
      password: 'testpassword123'
    });
    
    authToken = authData.session?.access_token!;
    testUserId = authData.user?.id!;
  });

  afterEach(async () => {
    // Cleanup
    await supabase
      .from('polls')
      .delete()
      .eq('creator_id', testUserId);
      
    await supabase.auth.signOut();
  });

  describe('POST /api/v1/polls', () => {
    it('should create a new poll', async () => {
      const pollData = {
        title: 'Test Meeting',
        description: 'Test description',
        options: [
          {
            option_date: '2025-07-01',
            time_slots: [
              {
                start_hour: 14,
                start_minute: 0,
                end_hour: 15,
                end_minute: 0,
                label: '14h00 - 15h00'
              }
            ]
          }
        ],
        participants: ['participant@example.com'],
        settings: {
          allow_anonymous_votes: true,
          send_notifications: false
        }
      };

      const response = await request(app)
        .post('/api/v1/polls')
        .set('Authorization', `Bearer ${authToken}`)
        .send(pollData)
        .expect(201);

      expect(response.body.poll).toMatchObject({
        title: 'Test Meeting',
        slug: 'test-meeting',
        status: 'draft'
      });
      expect(response.body.poll.share_url).toMatch(/^https:\/\/doodates\.app\/poll\//);
    });

    it('should validate required fields', async () => {
      const response = await request(app)
        .post('/api/v1/polls')
        .set('Authorization', `Bearer ${authToken}`)
        .send({})
        .expect(400);

      expect(response.body.errors).toContainEqual(
        expect.objectContaining({
          field: 'title',
          code: 'required'
        })
      );
    });

    it('should reject unauthorized requests', async () => {
      await request(app)
        .post('/api/v1/polls')
        .send({ title: 'Test' })
        .expect(401);
    });
  });

  describe('GET /api/v1/polls/:slug', () => {
    let testPoll: any;

    beforeEach(async () => {
      const { data } = await supabase
        .from('polls')
        .insert({
          title: 'Test Poll',
          slug: 'test-poll',
          creator_id: testUserId,
          status: 'active'
        })
        .select()
        .single();
      
      testPoll = data;
    });

    it('should return poll details for active polls', async () => {
      const response = await request(app)
        .get(`/api/v1/polls/${testPoll.slug}`)
        .expect(200);

      expect(response.body.poll).toMatchObject({
        title: 'Test Poll',
        slug: 'test-poll',
        status: 'active'
      });
    });

    it('should return 404 for non-existent polls', async () => {
      await request(app)
        .get('/api/v1/polls/non-existent')
        .expect(404);
    });
  });
});
```

#### Tests Database
```typescript
// tests/database/polls.test.ts
import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { supabase } from '../../src/lib/supabase';

describe('Database - Polls', () => {
  let testUserId: string;

  beforeEach(async () => {
    // Créer un utilisateur test
    const { data } = await supabase.auth.signUp({
      email: `test-${Date.now()}@example.com`,
      password: 'testpassword123'
    });
    testUserId = data.user?.id!;
  });

  afterEach(async () => {
    // Cleanup
    await supabase
      .from('polls')
      .delete()
      .eq('creator_id', testUserId);
  });

  it('should enforce RLS policies', async () => {
    // Créer un sondage
    const { data: poll } = await supabase
      .from('polls')
      .insert({
        title: 'Private Poll',
        slug: 'private-poll',
        creator_id: testUserId,
        status: 'draft'
      })
      .select()
      .single();

    // Tenter de lire avec un autre utilisateur (sans auth)
    const { data: publicData } = await supabase
      .from('polls')
      .select()
      .eq('id', poll.id);

    expect(publicData).toEqual([]); // RLS doit bloquer
  });

  it('should generate unique slugs', async () => {
    // Créer deux sondages avec le même titre
    const { data: poll1 } = await supabase
      .rpc('create_poll_with_slug', {
        p_title: 'Test Meeting',
        p_creator_id: testUserId
      });

    const { data: poll2 } = await supabase
      .rpc('create_poll_with_slug', {
        p_title: 'Test Meeting',
        p_creator_id: testUserId
      });

    expect(poll1.slug).toBe('test-meeting');
    expect(poll2.slug).toBe('test-meeting-1');
  });

  it('should cascade delete poll options and votes', async () => {
    // Créer un sondage avec options et votes
    const { data: poll } = await supabase
      .from('polls')
      .insert({
        title: 'Test Poll',
        slug: 'test-poll-cascade',
        creator_id: testUserId
      })
      .select()
      .single();

    await supabase
      .from('poll_options')
      .insert({
        poll_id: poll.id,
        option_date: '2025-07-01'
      });

    await supabase
      .from('votes')
      .insert({
        poll_id: poll.id,
        voter_email: 'voter@example.com',
        voter_name: 'Test Voter',
        selections: {}
      });

    // Supprimer le sondage
    await supabase
      .from('polls')
      .delete()
      .eq('id', poll.id);

    // Vérifier que les options et votes sont supprimés
    const { data: options } = await supabase
      .from('poll_options')
      .select()
      .eq('poll_id', poll.id);

    const { data: votes } = await supabase
      .from('votes')
      .select()
      .eq('poll_id', poll.id);

    expect(options).toEqual([]);
    expect(votes).toEqual([]);
  });
});
```

---

## Tests d'Intégration

### Tests IA
```typescript
// tests/integration/ai.test.ts
import { describe, it, expect, vi } from 'vitest';
import { AIService } from '../../src/services/aiService';
import { FunctionHandler } from '../../src/ai/functionHandlers';

describe('AI Integration', () => {
  let aiService: AIService;
  let functionHandler: FunctionHandler;

  beforeEach(() => {
    aiService = new AIService();
    functionHandler = new FunctionHandler();
  });

  it('should extract dates from natural language', async () => {
    const userMessage = "Organisons une réunion mardi 25 juin ou mercredi 26 juin";
    
    const response = await aiService.processMessage(userMessage, 'test-conversation');
    
    expect(response.extractedInfo.dates).toContain('2025-06-25');
    expect(response.extractedInfo.dates).toContain('2025-06-26');
    expect(response.extractedInfo.title).toMatch(/réunion/i);
  });

  it('should handle function calling for poll creation', async () => {
    const functionCall = {
      name: 'create_poll_draft',
      arguments: {
        title: 'Réunion équipe',
        dates: ['2025-07-01', '2025-07-02'],
        participants: ['test@example.com']
      }
    };

    const result = await functionHandler.createPollDraft(
      functionCall.arguments,
      'test-conversation'
    );

    expect(result.success).toBe(true);
    expect(result.poll_id).toBeDefined();
    expect(result.share_url).toMatch(/^https:\/\/doodates\.app\/poll\//);
  });

  it('should ask for clarification when information is incomplete', async () => {
    const userMessage = "Je veux organiser une réunion";
    
    const response = await aiService.processMessage(userMessage, 'test-conversation');
    
    expect(response.requiresClarification).toBe(true);
    expect(response.clarificationQuestion).toMatch(/date|quand/i);
  });

  it('should handle streaming responses', async () => {
    const messages = [];
    const onChunk = vi.fn((chunk) => messages.push(chunk));
    
    await aiService.streamResponse(
      "Organisons un dîner samedi",
      'test-conversation',
      onChunk
    );
    
    expect(onChunk).toHaveBeenCalled();
    expect(messages.some(msg => msg.includes('dîner'))).toBe(true);
  });
});
```

### Tests Real-time
```typescript
// tests/integration/realtime.test.ts
import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { createClient } from '@supabase/supabase-js';
import { WebSocket } from 'ws';

describe('Real-time Integration', () => {
  let supabase: any;
  let testPollId: string;
  
  beforeEach(async () => {
    supabase = createClient(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_ANON_KEY!
    );
    
    // Créer un sondage test
    const { data } = await supabase
      .from('polls')
      .insert({
        title: 'Realtime Test',
        slug: 'realtime-test',
        status: 'active'
      })
      .select()
      .single();
    
    testPollId = data.id;
  });

  afterEach(async () => {
    await supabase
      .from('polls')
      .delete()
      .eq('id', testPollId);
  });

  it('should receive real-time vote updates', (done) => {
    const updates: any[] = [];
    
    // S'abonner aux changements
    const channel = supabase
      .channel(`poll-${testPollId}`)
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'votes',
        filter: `poll_id=eq.${testPollId}`
      }, (payload: any) => {
        updates.push(payload);
        
        if (payload.eventType === 'INSERT') {
          expect(payload.new.voter_email).toBe('realtime@example.com');
          channel.unsubscribe();
          done();
        }
      })
      .subscribe();

    // Attendre la connexion puis créer un vote
    setTimeout(async () => {
      await supabase
        .from('votes')
        .insert({
          poll_id: testPollId,
          voter_email: 'realtime@example.com',
          voter_name: 'Realtime Voter',
          selections: {}
        });
    }, 1000);
  });

  it('should handle connection errors gracefully', async () => {
    const channel = supabase
      .channel('invalid-channel')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'invalid_table'
      }, () => {})
      .subscribe();

    // Vérifier que l'erreur est gérée
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    expect(channel.state).toBe('CLOSED');
  });
});
```

---

## Tests E2E (Playwright)

### Configuration Playwright
```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }]
  ],
  use: {
    baseURL: 'http://localhost:8080',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] }
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] }
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] }
    }
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:8080',
    reuseExistingServer: !process.env.CI
  }
});
```

### Tests E2E Complets
```typescript
// tests/e2e/poll-creation-flow.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Poll Creation Flow', () => {
  test('should create a complete poll from start to finish', async ({ page }) => {
    // 1. Navigation vers la page d'accueil
    await page.goto('/');
    await expect(page.locator('h1')).toContainText('DooDates');
    
    // 2. Clic sur le bouton de création
    await page.click('[data-testid="create-poll-btn"]');
    await expect(page).toHaveURL('/create');
    
    // 3. Sélection de dates
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const dayAfter = new Date();
    dayAfter.setDate(dayAfter.getDate() + 2);
    
    await page.click(`[data-date="${tomorrow.toISOString().split('T')[0]}"]`);
    await page.click(`[data-date="${dayAfter.toISOString().split('T')[0]}"]`);
    
    // Vérifier que les dates sont sélectionnées
    await expect(page.locator(`[data-date="${tomorrow.toISOString().split('T')[0]}"]`))
      .toHaveClass(/bg-blue-500/);
    
    // 4. Configuration des horaires
    await page.click('[data-testid="show-timeslots"]');
    await expect(page.locator('[data-testid="timeslots-grid"]')).toBeVisible();
    
    // Sélectionner quelques créneaux
    await page.click('[data-time="14:00"][data-date="${tomorrow.toISOString().split('T')[0]}"]');
    await page.click('[data-time="15:00"][data-date="${tomorrow.toISOString().split('T')[0]}"]');
    
    // 5. Configuration du partage
    await page.click('[data-testid="show-share"]');
    
    // Remplir le titre
    await page.fill('[data-testid="poll-title"]', 'Test E2E Meeting');
    
    // Ajouter des participants
    await page.fill('[data-testid="participant-emails"]', 'participant1@example.com, participant2@example.com');
    
    // 6. Création du sondage
    await page.click('[data-testid="create-poll"]');
    
    // 7. Vérification de la redirection
    await expect(page).toHaveURL(/\/poll\/test-e2e-meeting/);
    await expect(page.locator('h1')).toContainText('Test E2E Meeting');
    
    // 8. Vérifier que les options sont affichées
    await expect(page.locator('[data-testid="poll-option"]')).toHaveCount(2);
  });

  test('should handle mobile responsive design', async ({ page }) => {
    // Simuler un écran mobile
    await page.setViewportSize({ width: 375, height: 667 });
    
    await page.goto('/create');
    
    // Vérifier que le calendrier est responsive
    await expect(page.locator('[data-testid="calendar"]')).toBeVisible();
    
    // Vérifier que les boutons sont accessibles
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    await page.click(`[data-date="${tomorrow.toISOString().split('T')[0]}"]`);
    
    // Menu hamburger doit être visible
    await expect(page.locator('[data-testid="mobile-menu"]')).toBeVisible();
  });
});
```

### Tests de Vote
```typescript
// tests/e2e/voting-flow.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Voting Flow', () => {
  let pollUrl: string;

  test.beforeEach(async ({ page }) => {
    // Créer un sondage via l'API pour les tests
    const response = await page.request.post('/api/v1/polls', {
      data: {
        title: 'Test Voting Poll',
        options: [
          {
            option_date: '2025-07-01',
            time_slots: [
              {
                start_hour: 14,
                start_minute: 0,
                end_hour: 15,
                end_minute: 0,
                label: '14h00 - 15h00'
              }
            ]
          }
        ],
        participants: [],
        settings: { allow_anonymous_votes: true }
      },
      headers: {
        'Authorization': `Bearer ${process.env.TEST_AUTH_TOKEN}`
      }
    });
    
    const poll = await response.json();
    pollUrl = `/poll/${poll.poll.slug}`;
  });

  test('should allow anonymous voting', async ({ page }) => {
    await page.goto(pollUrl);
    
    // Remplir les informations du votant
    await page.fill('[data-testid="voter-name"]', 'Test Voter');
    await page.fill('[data-testid="voter-email"]', 'voter@example.com');
    
    // Voter sur les options
    await page.click('[data-testid="vote-yes"][data-option="0"]');
    
    // Soumettre le vote
    await page.click('[data-testid="submit-vote"]');
    
    // Vérifier la confirmation
    await expect(page.locator('[data-testid="vote-success"]')).toBeVisible();
    await expect(page.locator('[data-testid="vote-success"]'))
      .toContainText('Vote enregistré');
  });

  test('should show real-time vote updates', async ({ page, context }) => {
    // Ouvrir deux onglets pour tester le real-time
    const page1 = page;
    const page2 = await context.newPage();
    
    await page1.goto(pollUrl);
    await page2.goto(pollUrl);
    
    // Voter sur page1
    await page1.fill('[data-testid="voter-name"]', 'Voter 1');
    await page1.fill('[data-testid="voter-email"]', 'voter1@example.com');
    await page1.click('[data-testid="vote-yes"][data-option="0"]');
    await page1.click('[data-testid="submit-vote"]');
    
    // Vérifier que page2 voit la mise à jour
    await expect(page2.locator('[data-testid="vote-count-yes"]'))
      .toContainText('1');
  });

  test('should validate email format', async ({ page }) => {
    await page.goto(pollUrl);
    
    await page.fill('[data-testid="voter-name"]', 'Test Voter');
    await page.fill('[data-testid="voter-email"]', 'invalid-email');
    
    await page.click('[data-testid="submit-vote"]');
    
    await expect(page.locator('[data-testid="email-error"]'))
      .toContainText('Email invalide');
  });
});
```

---

## Tests de Performance

### Configuration Lighthouse
```typescript
// tests/performance/lighthouse.test.ts
import { test } from '@playwright/test';
import { playAudit } from 'playwright-lighthouse';

test.describe('Performance Tests', () => {
  test('should meet Lighthouse performance standards', async ({ page }) => {
    await page.goto('/');
    
    await playAudit({
      page,
      thresholds: {
        performance: 90,
        accessibility: 95,
        'best-practices': 90,
        seo: 80
      },
      port: 9222
    });
  });

  test('should load poll page quickly', async ({ page }) => {
    const startTime = Date.now();
    
    await page.goto('/poll/test-poll');
    await page.waitForLoadState('networkidle');
    
    const loadTime = Date.now() - startTime;
    
    // Doit charger en moins de 2 secondes
    expect(loadTime).toBeLessThan(2000);
  });
});
```

### Tests de Charge
```typescript
// tests/performance/load.test.ts
import { test } from '@playwright/test';

test.describe('Load Tests', () => {
  test('should handle multiple concurrent votes', async ({ browser }) => {
    const contexts = await Promise.all(
      Array.from({ length: 10 }, () => browser.newContext())
    );
    
    const pages = await Promise.all(
      contexts.map(context => context.newPage())
    );
    
    // Tous les utilisateurs votent simultanément
    const votes = pages.map(async (page, index) => {
      await page.goto('/poll/load-test-poll');
      await page.fill('[data-testid="voter-name"]', `Voter ${index}`);
      await page.fill('[data-testid="voter-email"]', `voter${index}@example.com`);
      await page.click('[data-testid="vote-yes"][data-option="0"]');
      await page.click('[data-testid="submit-vote"]');
      
      return page.waitForSelector('[data-testid="vote-success"]');
    });
    
    // Tous les votes doivent réussir
    await Promise.all(votes);
    
    // Cleanup
    await Promise.all(contexts.map(context => context.close()));
  });
});
```

---

## Tests de Sécurité

### Tests d'Authentification
```typescript
// tests/security/auth.test.ts
import { test, expect } from '@playwright/test';

test.describe('Security Tests', () => {
  test('should prevent unauthorized access to private polls', async ({ page }) => {
    // Tenter d'accéder à un sondage privé sans auth
    const response = await page.request.get('/api/v1/polls/private-poll-id');
    expect(response.status()).toBe(403);
  });

  test('should sanitize user inputs', async ({ page }) => {
    await page.goto('/create');
    
    // Tenter d'injecter du JavaScript
    const maliciousInput = '<script>alert("XSS")</script>';
    await page.fill('[data-testid="poll-title"]', maliciousInput);
    
    // Le contenu doit être échappé
    const titleValue = await page.inputValue('[data-testid="poll-title"]');
    expect(titleValue).not.toContain('<script>');
  });

  test('should enforce rate limiting', async ({ page }) => {
    // Faire de nombreuses requêtes rapidement
    const requests = Array.from({ length: 100 }, () =>
      page.request.post('/api/v1/polls', {
        data: { title: 'Rate limit test' }
      })
    );
    
    const responses = await Promise.all(requests);
    const tooManyRequests = responses.filter(r => r.status() === 429);
    
    expect(tooManyRequests.length).toBeGreaterThan(0);
  });
});
```

---

## CI/CD Pipeline

### GitHub Actions
```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run unit tests
        run: npm run test:unit
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info

  integration-tests:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Setup test database
        run: npm run db:setup:test
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
      
      - name: Run integration tests
        run: npm run test:integration
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_TEST_URL }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_TEST_ANON_KEY }}

  e2e-tests:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install Playwright
        run: npx playwright install --with-deps
      
      - name: Build application
        run: npm run build
      
      - name: Run E2E tests
        run: npm run test:e2e
        env:
          BASE_URL: http://localhost:8080
      
      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: failure()
        with:
          name: playwright-report
          path: playwright-report/
```

---

## Métriques et Couverture

### Objectifs de Couverture
- **Unit Tests :** 80% minimum
- **Integration Tests :** 70% minimum
- **E2E Tests :** Scénarios critiques couverts
- **Performance :** < 2s chargement, > 90 Lighthouse

### Reporting
```typescript
// scripts/test-report.ts
import fs from 'fs';
import path from 'path';

interface TestResults {
  unit: { passed: number; failed: number; coverage: number };
  integration: { passed: number; failed: number };
  e2e: { passed: number; failed: number };
  performance: { lighthouse: number; loadTime: number };
}

function generateTestReport(results: TestResults) {
  const report = `
# Test Report - ${new Date().toISOString()}

## Summary
- **Unit Tests:** ${results.unit.passed}/${results.unit.passed + results.unit.failed} (${results.unit.coverage}% coverage)
- **Integration Tests:** ${results.integration.passed}/${results.integration.passed + results.integration.failed}
- **E2E Tests:** ${results.e2e.passed}/${results.e2e.passed + results.e2e.failed}
- **Performance:** ${results.performance.lighthouse}/100 Lighthouse, ${results.performance.loadTime}ms load time

## Status
${results.unit.failed === 0 && results.integration.failed === 0 && results.e2e.failed === 0 ? '✅ All tests passing' : '❌ Some tests failing'}
  `;
  
  fs.writeFileSync(path.join(process.cwd(), 'test-report.md'), report);
}
```

---

**Document créé le 23 juin 2025**  
**Status :** Stratégie de tests complète Phase 2  
**Prochaine étape :** Implémentation des tests + CI/CD 