# DooDates - Schéma de Base de Données

**Document créé le 23 juin 2025**

## Vue d'Ensemble

### Architecture Base de Données
- **Provider :** Supabase (PostgreSQL)
- **Sécurité :** Row Level Security (RLS) activé
- **Environnements :** dev, staging, prod
- **Backup :** Automatique quotidien
- **Monitoring :** Supabase Dashboard + Sentry

---

## Tables Principales

### 1. Profiles (Utilisateurs)
Extension de la table `auth.users` de Supabase avec données métier.

```sql
CREATE TABLE profiles (
  id UUID REFERENCES auth.users(id) PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  full_name TEXT,
  avatar_url TEXT,
  timezone TEXT DEFAULT 'Europe/Paris',
  preferences JSONB DEFAULT '{}',
  plan_type TEXT DEFAULT 'free' CHECK (plan_type IN ('free', 'pro', 'premium')),
  subscription_expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**Champs `preferences` (JSONB) :**
```json
{
  "language": "fr",
  "notifications": {
    "email_invitations": true,
    "email_reminders": true,
    "push_notifications": false
  },
  "ui": {
    "theme": "light",
    "default_granularity": 60,
    "default_timezone": "Europe/Paris"
  },
  "privacy": {
    "public_profile": false,
    "allow_anonymous_votes": true
  }
}
```

**Indexes :**
```sql
CREATE INDEX idx_profiles_email ON profiles(email);
CREATE INDEX idx_profiles_plan ON profiles(plan_type);
```

**RLS Policies :**
```sql
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Utilisateur peut voir son profil uniquement
CREATE POLICY "Users can view own profile" ON profiles 
  FOR SELECT USING (auth.uid() = id);

-- Utilisateur peut modifier son profil uniquement
CREATE POLICY "Users can update own profile" ON profiles 
  FOR UPDATE USING (auth.uid() = id);

-- Création automatique du profil lors de l'inscription
CREATE POLICY "Users can insert own profile" ON profiles 
  FOR INSERT WITH CHECK (auth.uid() = id);
```

---

### 2. Polls (Sondages)
Table principale contenant les sondages créés.

```sql
CREATE TABLE polls (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  creator_id UUID REFERENCES profiles(id) NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  slug TEXT UNIQUE NOT NULL,
  settings JSONB DEFAULT '{}',
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'closed', 'archived')),
  expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**Champs `settings` (JSONB) :**
```json
{
  "time_granularity": 60,
  "allow_anonymous_votes": true,
  "allow_maybe_votes": true,
  "send_notifications": true,
  "auto_close": false,
  "max_votes_per_option": null,
  "require_all_fields": false,
  "custom_fields": [
    {
      "name": "phone",
      "label": "Numéro de téléphone",
      "type": "text",
      "required": false
    }
  ]
}
```

**États du sondage :**
- **draft** : Créé mais pas encore publié
- **active** : Publié et ouvert aux votes
- **closed** : Fermé manuellement ou automatiquement
- **archived** : Archivé par le créateur

**Génération du slug :**
```sql
-- Function pour générer un slug unique
CREATE OR REPLACE FUNCTION generate_poll_slug(poll_title TEXT)
RETURNS TEXT AS $$
DECLARE
  base_slug TEXT;
  final_slug TEXT;
  counter INTEGER := 1;
BEGIN
  -- Convertir le titre en slug
  base_slug := lower(regexp_replace(poll_title, '[^a-zA-Z0-9\s]', '', 'g'));
  base_slug := regexp_replace(base_slug, '\s+', '-', 'g');
  base_slug := trim(both '-' from base_slug);
  
  -- Limiter à 50 caractères
  base_slug := left(base_slug, 50);
  
  final_slug := base_slug;
  
  -- Vérifier l'unicité
  WHILE EXISTS (SELECT 1 FROM polls WHERE slug = final_slug) LOOP
    final_slug := base_slug || '-' || counter;
    counter := counter + 1;
  END LOOP;
  
  RETURN final_slug;
END;
$$ LANGUAGE plpgsql;
```

**Indexes :**
```sql
CREATE INDEX idx_polls_creator ON polls(creator_id);
CREATE INDEX idx_polls_slug ON polls(slug);
CREATE INDEX idx_polls_status ON polls(status);
CREATE INDEX idx_polls_created_at ON polls(created_at DESC);
```

**RLS Policies :**
```sql
ALTER TABLE polls ENABLE ROW LEVEL SECURITY;

-- Créateur peut tout faire sur ses sondages
CREATE POLICY "Creator can manage own polls" ON polls 
  FOR ALL USING (auth.uid() = creator_id);

-- Tout le monde peut voir les sondages actifs
CREATE POLICY "Anyone can view active polls" ON polls 
  FOR SELECT USING (status = 'active');
```

---

### 3. Poll_Options (Options de Sondage)
Dates et créneaux horaires proposés pour chaque sondage.

```sql
CREATE TABLE poll_options (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  poll_id UUID REFERENCES polls(id) ON DELETE CASCADE,
  option_date DATE NOT NULL,
  time_slots JSONB DEFAULT '[]',
  display_order INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**Champs `time_slots` (JSONB) :**
```json
[
  {
    "id": "slot-1",
    "start_hour": 14,
    "start_minute": 0,
    "end_hour": 15,
    "end_minute": 0,
    "label": "14h00 - 15h00"
  },
  {
    "id": "slot-2", 
    "start_hour": 15,
    "start_minute": 0,
    "end_hour": 16,
    "end_minute": 0,
    "label": "15h00 - 16h00"
  }
]
```

**Cas spéciaux :**
- **Journée entière :** `time_slots = []` (array vide)
- **Créneaux multiples :** Array avec plusieurs objets
- **Granularité variable :** Durées différentes selon les créneaux

**Indexes :**
```sql
CREATE INDEX idx_poll_options_poll ON poll_options(poll_id);
CREATE INDEX idx_poll_options_date ON poll_options(option_date);
CREATE INDEX idx_poll_options_order ON poll_options(poll_id, display_order);
```

**RLS Policies :**
```sql
ALTER TABLE poll_options ENABLE ROW LEVEL SECURITY;

-- Suit les mêmes règles que la table polls
CREATE POLICY "Poll options follow poll access" ON poll_options 
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM polls 
      WHERE polls.id = poll_id 
      AND (polls.creator_id = auth.uid() OR polls.status = 'active')
    )
  );

CREATE POLICY "Creator can manage poll options" ON poll_options 
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM polls 
      WHERE polls.id = poll_id 
      AND polls.creator_id = auth.uid()
    )
  );
```

---

### 4. Votes (Votes des Participants)
Réponses des participants aux sondages.

```sql
CREATE TABLE votes (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  poll_id UUID REFERENCES polls(id) ON DELETE CASCADE,
  voter_email TEXT NOT NULL,
  voter_name TEXT NOT NULL,
  voter_id UUID REFERENCES profiles(id), -- NULL si anonyme
  selections JSONB NOT NULL,
  comment TEXT,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(poll_id, voter_email)
);
```

**Champs `selections` (JSONB) :**
```json
{
  "option-uuid-1": {
    "vote": "yes",
    "time_slots": {
      "slot-1": "yes",
      "slot-2": "maybe"
    }
  },
  "option-uuid-2": {
    "vote": "no",
    "time_slots": {}
  }
}
```

**Types de vote :**
- **yes** : Disponible / Oui
- **no** : Pas disponible / Non
- **maybe** : Peut-être (si activé dans settings)

**Gestion anonyme vs connecté :**
- **Anonyme :** `voter_id = NULL`, identification par email uniquement
- **Connecté :** `voter_id` renseigné, email vérifié automatiquement

**Indexes :**
```sql
CREATE INDEX idx_votes_poll ON votes(poll_id);
CREATE INDEX idx_votes_email ON votes(voter_email);
CREATE INDEX idx_votes_user ON votes(voter_id) WHERE voter_id IS NOT NULL;
CREATE INDEX idx_votes_created_at ON votes(created_at DESC);
```

**RLS Policies :**
```sql
ALTER TABLE votes ENABLE ROW LEVEL SECURITY;

-- Votant peut voir/modifier ses propres votes
CREATE POLICY "Voters can manage own votes" ON votes 
  FOR ALL USING (
    voter_email = auth.email() 
    OR voter_id = auth.uid()
  );

-- Créateur du sondage peut voir tous les votes
CREATE POLICY "Poll creators can view all votes" ON votes 
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM polls 
      WHERE polls.id = poll_id 
      AND polls.creator_id = auth.uid()
    )
  );

-- Tout le monde peut voir les votes des sondages actifs (pour résultats temps réel)
CREATE POLICY "Anyone can view votes of active polls" ON votes 
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM polls 
      WHERE polls.id = poll_id 
      AND polls.status = 'active'
    )
  );
```

---

### 5. Conversations (Conversations IA)
Historique des conversations avec l'assistant IA.

```sql
CREATE TABLE conversations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES profiles(id),
  session_id TEXT NOT NULL,
  title TEXT,
  messages JSONB NOT NULL DEFAULT '[]',
  context JSONB DEFAULT '{}',
  poll_id UUID REFERENCES polls(id),
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'completed', 'abandoned')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**Champs `messages` (JSONB) :**
```json
[
  {
    "id": "msg-1",
    "role": "user",
    "content": "Je veux organiser une réunion mardi ou mercredi",
    "timestamp": "2025-06-23T14:30:00Z"
  },
  {
    "id": "msg-2",
    "role": "assistant", 
    "content": "Parfait ! Pour quelle semaine souhaitez-vous organiser cette réunion ?",
    "timestamp": "2025-06-23T14:30:02Z",
    "function_call": {
      "name": "ask_clarification",
      "arguments": {
        "question": "Pour quelle semaine souhaitez-vous organiser cette réunion ?",
        "options": ["Cette semaine", "Semaine prochaine", "Dans 2 semaines"]
      }
    }
  }
]
```

**Champs `context` (JSONB) :**
```json
{
  "extracted_info": {
    "title": "Réunion équipe",
    "dates": ["2025-07-01", "2025-07-02"],
    "participants": ["paul@example.com", "marie@example.com"],
    "time_preference": "afternoon",
    "location": "Salle de réunion A"
  },
  "clarifications_needed": ["specific_time", "duration"],
  "confidence_score": 0.85
}
```

**Gestion des sessions :**
- **Utilisateur connecté :** `user_id` renseigné
- **Utilisateur anonyme :** `user_id = NULL`, identification par `session_id`
- **Session expiry :** 30 jours d'inactivité

**Indexes :**
```sql
CREATE INDEX idx_conversations_user ON conversations(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX idx_conversations_session ON conversations(session_id);
CREATE INDEX idx_conversations_poll ON conversations(poll_id) WHERE poll_id IS NOT NULL;
CREATE INDEX idx_conversations_status ON conversations(status);
CREATE INDEX idx_conversations_updated_at ON conversations(updated_at DESC);
```

**RLS Policies :**
```sql
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;

-- Utilisateur peut voir ses conversations
CREATE POLICY "Users can view own conversations" ON conversations 
  FOR SELECT USING (
    auth.uid() = user_id 
    OR (user_id IS NULL AND session_id = current_setting('app.session_id', true))
  );

-- Utilisateur peut modifier ses conversations
CREATE POLICY "Users can update own conversations" ON conversations 
  FOR UPDATE USING (
    auth.uid() = user_id 
    OR (user_id IS NULL AND session_id = current_setting('app.session_id', true))
  );

-- Création de nouvelles conversations
CREATE POLICY "Users can create conversations" ON conversations 
  FOR INSERT WITH CHECK (
    auth.uid() = user_id 
    OR user_id IS NULL
  );
```

---

### 6. Analytics_Events (Événements Analytics)
Tracking des événements pour analytics et monitoring.

```sql
CREATE TABLE analytics_events (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  event_type TEXT NOT NULL,
  event_data JSONB NOT NULL,
  user_id UUID REFERENCES profiles(id),
  session_id TEXT,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**Types d'événements :**
- **poll_created** : Sondage créé
- **poll_shared** : Sondage partagé
- **vote_cast** : Vote effectué
- **conversation_started** : Conversation IA démarrée
- **user_signup** : Inscription utilisateur
- **page_view** : Page visitée

**Exemple `event_data` :**
```json
{
  "poll_id": "uuid-here",
  "poll_title": "Réunion équipe",
  "creation_method": "manual",
  "options_count": 3,
  "has_time_slots": true,
  "participants_count": 5
}
```

**Indexes :**
```sql
CREATE INDEX idx_analytics_type ON analytics_events(event_type);
CREATE INDEX idx_analytics_user ON analytics_events(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX idx_analytics_created_at ON analytics_events(created_at DESC);
CREATE INDEX idx_analytics_session ON analytics_events(session_id) WHERE session_id IS NOT NULL;
```

**RLS Policies :**
```sql
ALTER TABLE analytics_events ENABLE ROW LEVEL SECURITY;

-- Seuls les admins peuvent voir les analytics (pour l'instant)
CREATE POLICY "Admins can view analytics" ON analytics_events 
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE profiles.id = auth.uid() 
      AND profiles.preferences->>'role' = 'admin'
    )
  );

-- Système peut insérer des événements
CREATE POLICY "System can insert analytics" ON analytics_events 
  FOR INSERT WITH CHECK (true);
```

---

## Vues Utiles

### Vue des Sondages avec Statistiques
```sql
CREATE VIEW polls_with_stats AS
SELECT 
  p.*,
  pr.full_name as creator_name,
  pr.email as creator_email,
  COUNT(DISTINCT po.id) as options_count,
  COUNT(DISTINCT v.id) as votes_count,
  COUNT(DISTINCT v.voter_email) as unique_voters_count,
  MAX(v.updated_at) as last_vote_at
FROM polls p
LEFT JOIN profiles pr ON pr.id = p.creator_id
LEFT JOIN poll_options po ON po.poll_id = p.id
LEFT JOIN votes v ON v.poll_id = p.id
GROUP BY p.id, pr.full_name, pr.email;
```

### Vue des Résultats de Vote
```sql
CREATE VIEW vote_results AS
SELECT 
  po.poll_id,
  po.id as option_id,
  po.option_date,
  po.time_slots,
  COUNT(CASE WHEN v.selections->po.id::text->>'vote' = 'yes' THEN 1 END) as yes_count,
  COUNT(CASE WHEN v.selections->po.id::text->>'vote' = 'no' THEN 1 END) as no_count,
  COUNT(CASE WHEN v.selections->po.id::text->>'vote' = 'maybe' THEN 1 END) as maybe_count,
  COUNT(v.id) as total_votes
FROM poll_options po
LEFT JOIN votes v ON v.poll_id = po.poll_id
GROUP BY po.poll_id, po.id, po.option_date, po.time_slots;
```

---

## Triggers et Functions

### Trigger pour mise à jour automatique des timestamps
```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language 'plpgsql';

-- Application sur les tables nécessaires
CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON profiles 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_polls_updated_at BEFORE UPDATE ON polls 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_votes_updated_at BEFORE UPDATE ON votes 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_conversations_updated_at BEFORE UPDATE ON conversations 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### Function pour création automatique du profil
```sql
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO profiles (id, email, full_name, avatar_url)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name'),
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$ language 'plpgsql' SECURITY DEFINER;

-- Trigger sur l'inscription
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();
```

---

## Migration et Backup

### Scripts de Migration
```sql
-- Migration initiale (001_initial_schema.sql)
-- Contient toutes les tables, indexes, RLS policies

-- Migration 002 (002_add_analytics.sql)
-- Ajout de la table analytics_events

-- Migration 003 (003_add_poll_settings.sql)
-- Ajout de champs dans settings JSONB
```

### Stratégie de Backup
- **Backup automatique** : Quotidien via Supabase
- **Backup manuel** : Avant chaque déploiement
- **Retention** : 30 jours pour dev, 90 jours pour prod
- **Test de restore** : Mensuel sur environnement de test

---

**Document créé le 23 juin 2025**  
**Status :** Schéma complet Phase 2  
**Prochaine étape :** Implémentation Supabase 