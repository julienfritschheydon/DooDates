<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Conversations - DooDates</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #0a0a0a;
            color: #fff;
        }
        h1 { color: #60a5fa; }
        h2 { color: #a78bfa; margin-top: 30px; }
        .section {
            background: #1e1e1e;
            border: 1px solid #3c4043;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .item {
            background: #2a2a2a;
            border-left: 4px solid #60a5fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .poll-item {
            border-left-color: #a78bfa;
        }
        .duplicate {
            border-left-color: #ef4444;
            background: #2a1a1a;
        }
        .orphan {
            border-left-color: #f59e0b;
            background: #2a2410;
        }
        .key { 
            color: #60a5fa;
            font-weight: bold;
        }
        .value {
            color: #d4d4d8;
            margin-left: 10px;
        }
        button {
            background: #60a5fa;
            color: #0a0a0a;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }
        button:hover {
            background: #3b82f6;
        }
        .danger {
            background: #ef4444;
            color: white;
        }
        .danger:hover {
            background: #dc2626;
        }
        pre {
            background: #0a0a0a;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
        }
        .info {
            background: #1e3a5f;
            border-left: 4px solid #60a5fa;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>üîç Debug Conversations & Polls - DooDates</h1>
    
    <div class="info">
        <strong>‚ÑπÔ∏è Instructions :</strong>
        <ul>
            <li>Ouvrez cet outil depuis le m√™me domaine que votre application DooDates (ex: <code>http://localhost:5173/debug-conversations.html</code>)</li>
            <li>Les donn√©es seront lues depuis le localStorage de votre navigateur</li>
            <li>Cet outil fonctionne uniquement en local, pas via GitHub Pages</li>
        </ul>
    </div>
    
    <div class="section">
        <button onclick="analyzeData()">Analyser les donn√©es</button>
        <button onclick="findDuplicates()">Trouver les doublons</button>
        <button onclick="findOrphans()">Trouver les orphelins</button>
        <button class="danger" onclick="cleanupOrphans()">Nettoyer les orphelins</button>
        <button class="danger" onclick="cleanupDuplicates()">Nettoyer les doublons de conversations</button>
    </div>

    <div id="results"></div>

    <script>
        // Try multiple storage keys (legacy and new)
        function getStorageData() {
            // Try different possible storage keys
            const storageKeys = {
                conversations: ['doodates_conversations', 'conversations'],
                polls: ['doodates_polls', 'dev-polls']
            };
            
            let conversations = [];
            let polls = [];
            
            for (const key of storageKeys.conversations) {
                const data = localStorage.getItem(key);
                if (data) {
                    try {
                        conversations = JSON.parse(data);
                        console.log(`Found conversations in key: ${key}`);
                        break;
                    } catch (e) {
                        console.warn(`Failed to parse ${key}:`, e);
                    }
                }
            }
            
            for (const key of storageKeys.polls) {
                const data = localStorage.getItem(key);
                if (data) {
                    try {
                        polls = JSON.parse(data);
                        console.log(`Found polls in key: ${key}`);
                        break;
                    } catch (e) {
                        console.warn(`Failed to parse ${key}:`, e);
                    }
                }
            }
            
            return { conversations, polls };
        }

        function analyzeData() {
            const { conversations, polls } = getStorageData();
            
            let html = '<h2>üìä Statistiques</h2><div class="section">';
            html += `<p><span class="key">Conversations:</span> <span class="value">${conversations.length}</span></p>`;
            html += `<p><span class="key">Polls:</span> <span class="value">${polls.length}</span></p>`;
            html += '</div>';

            // Group conversations by poll
            const conversationsByPoll = {};
            conversations.forEach(conv => {
                const pollId = conv.pollId || conv.relatedPollId;
                if (pollId) {
                    if (!conversationsByPoll[pollId]) {
                        conversationsByPoll[pollId] = [];
                    }
                    conversationsByPoll[pollId].push(conv);
                }
            });

            // Find polls with multiple conversations
            html += '<h2>‚ö†Ô∏è Polls avec plusieurs conversations</h2>';
            let hasDuplicates = false;
            Object.entries(conversationsByPoll).forEach(([pollId, convs]) => {
                if (convs.length > 1) {
                    hasDuplicates = true;
                    const poll = polls.find(p => p.id === pollId);
                    html += `<div class="section duplicate">`;
                    html += `<p><span class="key">Poll:</span> <span class="value">${poll ? poll.title : pollId}</span></p>`;
                    html += `<p><span class="key">Poll ID:</span> <span class="value">${pollId}</span></p>`;
                    html += `<p><span class="key">Nombre de conversations:</span> <span class="value">${convs.length}</span></p>`;
                    html += '<details><summary>D√©tails des conversations</summary><pre>';
                    html += JSON.stringify(convs, null, 2);
                    html += '</pre></details>';
                    html += '</div>';
                }
            });
            
            if (!hasDuplicates) {
                html += '<p>Aucun poll avec plusieurs conversations ‚úÖ</p>';
            }

            // List all conversations
            html += '<h2>üí¨ Toutes les conversations</h2>';
            if (conversations.length === 0) {
                html += '<p>Aucune conversation trouv√©e</p>';
            } else {
                conversations.forEach((conv, i) => {
                    const pollId = conv.pollId || conv.relatedPollId;
                    const poll = pollId ? polls.find(p => p.id === pollId) : null;
                    
                    html += `<div class="item">`;
                    html += `<p><span class="key">ID:</span> <span class="value">${conv.id}</span></p>`;
                    html += `<p><span class="key">Titre:</span> <span class="value">${conv.title}</span></p>`;
                    html += `<p><span class="key">Poll ID:</span> <span class="value">${pollId || 'Aucun'}</span></p>`;
                    if (poll) {
                        html += `<p><span class="key">Poll Titre:</span> <span class="value">${poll.title}</span></p>`;
                    }
                    html += `<p><span class="key">Cr√©√©:</span> <span class="value">${new Date(conv.createdAt || conv.created_at).toLocaleString('fr-FR')}</span></p>`;
                    html += '<details><summary>Voir JSON complet</summary><pre>';
                    html += JSON.stringify(conv, null, 2);
                    html += '</pre></details>';
                    html += '</div>';
                });
            }

            // List all polls
            html += '<h2>üìã Tous les polls</h2>';
            if (polls.length === 0) {
                html += '<p>Aucun poll trouv√©</p>';
            } else {
                polls.forEach(poll => {
                    const linkedConvs = conversations.filter(c => 
                        c.pollId === poll.id || c.relatedPollId === poll.id
                    );
                    
                    html += `<div class="item poll-item">`;
                    html += `<p><span class="key">ID:</span> <span class="value">${poll.id}</span></p>`;
                    html += `<p><span class="key">Titre:</span> <span class="value">${poll.title}</span></p>`;
                    html += `<p><span class="key">Type:</span> <span class="value">${poll.type || 'date'}</span></p>`;
                    html += `<p><span class="key">Conversations li√©es:</span> <span class="value">${linkedConvs.length}</span></p>`;
                    html += `<p><span class="key">Cr√©√©:</span> <span class="value">${new Date(poll.created_at).toLocaleString('fr-FR')}</span></p>`;
                    html += '<details><summary>Voir JSON complet</summary><pre>';
                    html += JSON.stringify(poll, null, 2);
                    html += '</pre></details>';
                    html += '</div>';
                });
            }

            document.getElementById('results').innerHTML = html;
        }

        function findDuplicates() {
            const { conversations, polls } = getStorageData();
            
            let html = '<h2>üîç Recherche de doublons</h2>';
            
            // Find duplicate polls by title
            const pollsByTitle = {};
            polls.forEach(poll => {
                if (!pollsByTitle[poll.title]) {
                    pollsByTitle[poll.title] = [];
                }
                pollsByTitle[poll.title].push(poll);
            });

            html += '<h3>Polls avec le m√™me titre:</h3>';
            let foundTitleDuplicates = false;
            Object.entries(pollsByTitle).forEach(([title, pollList]) => {
                if (pollList.length > 1) {
                    foundTitleDuplicates = true;
                    html += `<div class="section duplicate">`;
                    html += `<p><span class="key">Titre:</span> <span class="value">${title}</span></p>`;
                    html += `<p><span class="key">Nombre de polls:</span> <span class="value">${pollList.length}</span></p>`;
                    pollList.forEach(poll => {
                        const linkedConvs = conversations.filter(c => 
                            c.pollId === poll.id || c.relatedPollId === poll.id
                        );
                        html += `<p style="margin-left: 20px;">‚Ä¢ Poll ID: ${poll.id} (${linkedConvs.length} conversation(s))</p>`;
                    });
                    html += '</div>';
                }
            });
            
            if (!foundTitleDuplicates) {
                html += '<p>Aucun doublon de titre trouv√© ‚úÖ</p>';
            }

            document.getElementById('results').innerHTML = html;
        }

        function findOrphans() {
            const { conversations, polls } = getStorageData();
            const pollIds = new Set(polls.map(p => p.id));
            
            let html = '<h2>üëª Conversations orphelines</h2>';
            
            const orphans = conversations.filter(conv => {
                const pollId = conv.pollId || conv.relatedPollId;
                return pollId && !pollIds.has(pollId);
            });

            if (orphans.length === 0) {
                html += '<p>Aucune conversation orpheline trouv√©e ‚úÖ</p>';
            } else {
                html += `<p>Trouv√© ${orphans.length} conversation(s) orpheline(s):</p>`;
                orphans.forEach(conv => {
                    html += `<div class="item orphan">`;
                    html += `<p><span class="key">ID:</span> <span class="value">${conv.id}</span></p>`;
                    html += `<p><span class="key">Titre:</span> <span class="value">${conv.title}</span></p>`;
                    html += `<p><span class="key">Poll ID (manquant):</span> <span class="value">${conv.pollId || conv.relatedPollId}</span></p>`;
                    html += '</div>';
                });
            }

            document.getElementById('results').innerHTML = html;
        }

        function cleanupOrphans() {
            if (!confirm('√ätes-vous s√ªr de vouloir nettoyer les conversations orphelines ?')) {
                return;
            }

            const { conversations, polls } = getStorageData();
            const pollIds = new Set(polls.map(p => p.id));
            
            const cleaned = conversations.map(conv => {
                const pollId = conv.pollId || conv.relatedPollId;
                if (pollId && !pollIds.has(pollId)) {
                    // Remove poll references
                    return {
                        ...conv,
                        pollId: undefined,
                        relatedPollId: undefined,
                        pollType: undefined,
                        pollStatus: undefined,
                        tags: conv.tags ? conv.tags.filter(t => !t.startsWith('poll:')) : [],
                        metadata: conv.metadata ? {
                            ...conv.metadata,
                            pollGenerated: undefined,
                            pollTitle: undefined,
                            pollId: undefined,
                        } : undefined
                    };
                }
                return conv;
            });

            localStorage.setItem('doodates_conversations', JSON.stringify(cleaned));
            alert('Nettoyage effectu√© ! Rechargez la page pour voir les changements.');
            analyzeData();
        }

        function cleanupDuplicates() {
            if (!confirm('√ätes-vous s√ªr de vouloir nettoyer les conversations en doublon pour chaque poll ?\n\nPour chaque poll, on garde la conversation avec des messages (si elle existe) ou la plus ancienne. Les autres seront d√©tach√©es.')) {
                return;
            }

            const { conversations, polls } = getStorageData();
            
            // Group conversations by poll
            const conversationsByPoll = {};
            conversations.forEach(conv => {
                const pollId = conv.pollId || conv.relatedPollId;
                if (pollId) {
                    if (!conversationsByPoll[pollId]) {
                        conversationsByPoll[pollId] = [];
                    }
                    conversationsByPoll[pollId].push(conv);
                }
            });

            let cleanedCount = 0;
            const cleaned = conversations.map(conv => {
                const pollId = conv.pollId || conv.relatedPollId;
                if (!pollId) return conv;
                
                const pollConvs = conversationsByPoll[pollId];
                if (pollConvs && pollConvs.length > 1) {
                    // Priority: keep conversation with messages > oldest conversation
                    const sorted = pollConvs.sort((a, b) => {
                        const aHasMessages = (a.messageCount || 0) > 0;
                        const bHasMessages = (b.messageCount || 0) > 0;
                        
                        // If one has messages and the other doesn't, prioritize the one with messages
                        if (aHasMessages && !bHasMessages) return -1;
                        if (!aHasMessages && bHasMessages) return 1;
                        
                        // Otherwise, keep the oldest
                        return new Date(a.createdAt || a.created_at).getTime() - new Date(b.createdAt || b.created_at).getTime();
                    });
                    
                    // Keep the first one (highest priority), detach others
                    if (conv.id !== sorted[0].id) {
                        // This is a duplicate, detach it
                        cleanedCount++;
                        return {
                            ...conv,
                            pollId: undefined,
                            relatedPollId: undefined,
                            pollType: undefined,
                            pollStatus: undefined,
                            tags: conv.tags ? conv.tags.filter(t => t !== `poll:${pollId}` && !t.startsWith('poll:')) : [],
                            metadata: conv.metadata ? {
                                ...conv.metadata,
                                pollGenerated: undefined,
                                pollTitle: undefined,
                                pollId: undefined,
                            } : undefined
                        };
                    }
                }
                return conv;
            });

            localStorage.setItem('doodates_conversations', JSON.stringify(cleaned));
            alert(`Nettoyage effectu√© ! ${cleanedCount} conversation(s) d√©tach√©e(s).\n\nRechargez la page pour voir les changements.`);
            analyzeData();
        }

        // Auto-analyze on load
        window.onload = analyzeData;
    </script>
</body>
</html>

