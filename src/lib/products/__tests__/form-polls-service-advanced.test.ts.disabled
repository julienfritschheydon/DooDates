import { describe, it, expect, beforeEach, vi } from "vitest";
import {
  getFormPolls,
  addFormPoll,
  deleteFormPollById,
  duplicateFormPoll,
  getFormPollBySlugOrId,
  saveFormPolls,
  addFormResponse,
  getFormResponses,
  getFormResults,
  validateFormPoll,
  type FormPoll,
  type FormQuestionShape,
  type FormResponseItem,
} from "../form-polls/form-polls-service";

// Mock localStorage
const localStorageMock = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn(),
};
Object.defineProperty(window, "localStorage", { value: localStorageMock });

describe("FormPollsService - Advanced Tests", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    localStorageMock.getItem.mockReturnValue(null);
  });

  describe("Custom Question Types", () => {
    it("should validate custom question types", () => {
      const customQuestion: FormQuestionShape = {
        id: "q1",
        kind: "rating" as any, // Custom type
        question: "Rate your experience",
        required: true,
        options: [
          { id: "opt1", text: "1 star", value: 1 },
          { id: "opt2", text: "2 stars", value: 2 },
          { id: "opt3", text: "3 stars", value: 3 },
          { id: "opt4", text: "4 stars", value: 4 },
          { id: "opt5", text: "5 stars", value: 5 }
        ]
      };

      const poll: FormPoll = {
        id: "form_1",
        creator_id: "user_1",
        title: "Custom Question Test",
        description: "Test custom question types",
        type: "form",
        slug: "custom-question-test",
        created_at: new Date().toISOString(),
        questions: [customQuestion],
        responses: []
      };

      const result = validateFormPoll(poll);
      expect(result.isValid).toBe(true);
    });

    it("should handle matrix-style questions", () => {
      const matrixQuestion: FormQuestionShape = {
        id: "q1",
        kind: "matrix" as any,
        question: "Rate each aspect",
        required: true,
        options: [
          { id: "opt1", text: "Poor", value: 1 },
          { id: "opt2", text: "Fair", value: 2 },
          { id: "opt3", text: "Good", value: 3 },
          { id: "opt4", text: "Excellent", value: 4 }
        ],
        rows: ["Quality", "Price", "Service"] as any // Custom property for matrix
      };

      const poll: FormPoll = {
        id: "form_1",
        creator_id: "user_1",
        title: "Matrix Question Test",
        description: "Test matrix questions",
        type: "form",
        slug: "matrix-question-test",
        created_at: new Date().toISOString(),
        questions: [matrixQuestion],
        responses: []
      };

      const result = validateFormPoll(poll);
      expect(result.isValid).toBe(true);
    });

    it("should validate conditional questions", () => {
      const conditionalQuestion: FormQuestionShape = {
        id: "q2",
        kind: "single",
        question: "Which brand do you prefer?",
        required: true,
        options: [
          { id: "opt1", text: "Brand A", value: "brand_a" },
          { id: "opt2", text: "Brand B", value: "brand_b" },
          { id: "opt3", text: "Brand C", value: "brand_c" }
        ],
        condition: {
          questionId: "q1",
          value: "yes"
        } as any // Custom property for conditional logic
      };

      const poll: FormPoll = {
        id: "form_1",
        creator_id: "user_1",
        title: "Conditional Question Test",
        description: "Test conditional questions",
        type: "form",
        slug: "conditional-question-test",
        created_at: new Date().toISOString(),
        questions: [
          {
            id: "q1",
            kind: "single",
            question: "Do you use our product?",
            required: true,
            options: [
              { id: "opt1", text: "Yes", value: "yes" },
              { id: "opt2", text: "No", value: "no" }
            ]
          },
          conditionalQuestion
        ],
        responses: []
      };

      const result = validateFormPoll(poll);
      expect(result.isValid).toBe(true);
    });
  });

  describe("Performance with Many Respondents", () => {
    it("should handle large number of responses efficiently", () => {
      const question: FormQuestionShape = {
        id: "q1",
        kind: "single",
        question: "Choose option",
        required: true,
        options: [
          { id: "opt1", text: "Option 1", value: "opt1" },
          { id: "opt2", text: "Option 2", value: "opt2" }
        ]
      };

      const poll: FormPoll = {
        id: "form_1",
        creator_id: "user_1",
        title: "Popular Form",
        description: "Test with many responses",
        type: "form",
        slug: "popular-form",
        created_at: new Date().toISOString(),
        questions: [question],
        responses: []
      };

      // Add 1000 responses
      const manyResponses = Array.from({ length: 1000 }, (_, i) => ({
        id: `resp_${i}`,
        user_id: `user_${i}`,
        poll_id: "form_1",
        created_at: new Date().toISOString(),
        answers: {
          q1: i % 2 === 0 ? "opt1" : "opt2"
        }
      }));

      poll.responses = manyResponses;

      const startTime = performance.now();
      const results = getFormResults(poll);
      const endTime = performance.now();

      expect(results).toBeDefined();
      expect(endTime - startTime).toBeLessThan(100); // Should complete in <100ms
    });

    it("should handle complex calculations efficiently", () => {
      const questions: FormQuestionShape[] = Array.from({ length: 50 }, (_, i) => ({
        id: `q${i + 1}`,
        kind: "single",
        question: `Question ${i + 1}`,
        required: true,
        options: [
          { id: `opt${i}_1`, text: "Option 1", value: "opt1" },
          { id: `opt${i}_2`, text: "Option 2", value: "opt2" }
        ]
      }));

      const poll: FormPoll = {
        id: "form_complex",
        creator_id: "user_1",
        title: "Complex Form",
        description: "Test with many questions",
        type: "form",
        slug: "complex-form",
        created_at: new Date().toISOString(),
        questions,
        responses: Array.from({ length: 500 }, (_, i) => ({
          id: `resp_${i}`,
          user_id: `user_${i}`,
          poll_id: "form_complex",
          created_at: new Date().toISOString(),
          answers: Object.fromEntries(
            questions.map(q => [q.id, Math.random() > 0.5 ? `opt${q.id.split('q')[1]}_1` : `opt${q.id.split('q')[1]}_2`])
          )
        }))
      };

      const startTime = performance.now();
      const results = getFormResults(poll);
      const endTime = performance.now();

      expect(Object.keys(results)).toHaveLength(50);
      expect(endTime - startTime).toBeLessThan(200); // Should complete in <200ms
    });
  });

  describe("Partial Responses", () => {
    it("should handle incomplete form submissions", () => {
      const poll: FormPoll = {
        id: "form_1",
        creator_id: "user_1",
        title: "Partial Response Test",
        description: "Test partial responses",
        type: "form",
        slug: "partial-response-test",
        created_at: new Date().toISOString(),
        questions: [
          {
            id: "q1",
            kind: "single",
            question: "Required question",
            required: true,
            options: [
              { id: "opt1", text: "Option 1", value: "opt1" },
              { id: "opt2", text: "Option 2", value: "opt2" }
            ]
          },
          {
            id: "q2",
            kind: "single",
            question: "Optional question",
            required: false,
            options: [
              { id: "opt3", text: "Option 3", value: "opt3" },
              { id: "opt4", text: "Option 4", value: "opt4" }
            ]
          }
        ],
        responses: []
      };

      // Add partial response (only required question answered)
      const partialResponse: FormResponseItem = {
        id: "resp_1",
        user_id: "user_1",
        poll_id: "form_1",
        created_at: new Date().toISOString(),
        answers: {
          q1: "opt1"
          // q2 is missing (optional)
        }
      };

      poll.responses = [partialResponse];

      const results = getFormResults(poll);
      expect(results.q1).toBeDefined();
      expect(results.q2).toBeDefined(); // Should handle missing optional answers
    });

    it("should validate required fields in partial responses", () => {
      const poll: FormPoll = {
        id: "form_1",
        creator_id: "user_1",
        title: "Required Field Test",
        description: "Test required field validation",
        type: "form",
        slug: "required-field-test",
        created_at: new Date().toISOString(),
        questions: [
          {
            id: "q1",
            kind: "single",
            question: "Required question",
            required: true,
            options: [
              { id: "opt1", text: "Option 1", value: "opt1" },
              { id: "opt2", text: "Option 2", value: "opt2" }
            ]
          }
        ],
        responses: []
      };

      // Try to add response without required field
      const incompleteResponse: FormResponseItem = {
        id: "resp_1",
        user_id: "user_1",
        poll_id: "form_1",
        created_at: new Date().toISOString(),
        answers: {} // Missing required q1
      };

      expect(() => addFormResponse(poll, incompleteResponse)).toThrow();
    });
  });

  describe("Edge Cases", () => {
    it("should handle empty options gracefully", () => {
      const invalidQuestion: FormQuestionShape = {
        id: "q1",
        kind: "single",
        question: "Invalid question",
        required: true,
        options: [] // No options
      };

      const poll: FormPoll = {
        id: "form_invalid",
        creator_id: "user_1",
        title: "Invalid Question Test",
        description: "Test with invalid question",
        type: "form",
        slug: "invalid-question-test",
        created_at: new Date().toISOString(),
        questions: [invalidQuestion],
        responses: []
      };

      const result = validateFormPoll(poll);
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain("Question must have at least one option");
    });

    it("should handle malformed response data", () => {
      const question: FormQuestionShape = {
        id: "q1",
        kind: "single",
        question: "Test question",
        required: true,
        options: [
          { id: "opt1", text: "Option 1", value: "opt1" },
          { id: "opt2", text: "Option 2", value: "opt2" }
        ]
      };

      const poll: FormPoll = {
        id: "form_1",
        creator_id: "user_1",
        title: "Malformed Response Test",
        description: "Test with malformed data",
        type: "form",
        slug: "malformed-response-test",
        created_at: new Date().toISOString(),
        questions: [question],
        responses: []
      };

      // Add response with invalid option value
      const malformedResponse: FormResponseItem = {
        id: "resp_1",
        user_id: "user_1",
        poll_id: "form_1",
        created_at: new Date().toISOString(),
        answers: {
          q1: "invalid_option" // Not in options
        }
      };

      expect(() => addFormResponse(poll, malformedResponse)).toThrow();
    });
  });
});
