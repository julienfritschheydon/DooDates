/**
 * useAutoSave Hook
 * Automatic conversation persistence for chat sessions
 * DooDates - Conversation History System
 */

import { useCallback, useEffect, useRef, useState } from "react";
import { useAuth } from "../contexts/AuthContext";
import * as ConversationStorage from "../lib/storage/ConversationStorageSimple";
import {
  generateConversationTitle,
  shouldRegenerateTitle,
} from "../lib/services/titleGeneration";
import type { Conversation, ConversationMessage } from "../types/conversation";
import { ConversationError } from "../types/conversation";
import { logger } from "@/lib/logger";

export interface AutoSaveMessage {
  id: string;
  content: string;
  isAI: boolean;
  timestamp: Date;
  pollSuggestion?: any; // Deprecated - use metadata.pollSuggestion instead
  metadata?: {
    pollGenerated?: boolean;
    pollSuggestion?: any;
    [key: string]: any;
  };
}

export interface UseAutoSaveOptions {
  /** Enable debug logging */
  debug?: boolean;
}

export interface UseAutoSaveReturn {
  conversationId: string | null;
  isAutoSaving: boolean;
  lastSaved: Date | null;
  addMessage: (message: AutoSaveMessage) => void;
  startNewConversation: (title?: string) => Promise<string>;
  resumeConversation: (id: string) => Promise<Conversation | null>;
  getCurrentConversation: () => Promise<{
    conversation: Conversation;
    messages: ConversationMessage[];
  } | null>;
  clearConversation: () => void;
  getRealConversationId: () => string | null;
}

/**
 * Hook for automatic conversation saving with localStorage
 */
export function useAutoSave(opts: UseAutoSaveOptions = {}): UseAutoSaveReturn {
  const { user } = useAuth();
  const { debug = false } = opts;

  // State
  const [conversationId, setConversationId] = useState<string | null>(null);
  const [isAutoSaving, setIsAutoSaving] = useState(false);
  const [lastSaved, setLastSaved] = useState<Date | null>(null);

  // Refs
  const currentConversationRef = useRef<Conversation | null>(null);
  const titleGenerationTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Debug logging (reduced for production)
  const log = useCallback(
    (message: string, data?: any) => {
      if (debug && message.includes("Error")) {
        logger.debug(`AutoSave: ${message}`, "conversation", data || {});
      }
    },
    [debug],
  );

  // Convert AutoSaveMessage to ConversationMessage
  const convertMessage = useCallback(
    (msg: AutoSaveMessage, conversationId: string): ConversationMessage => ({
      id: msg.id,
      conversationId,
      role: msg.isAI ? "assistant" : "user",
      content: msg.content,
      timestamp: msg.timestamp,
      // PRIORITÉ 1: Utiliser metadata si fourni (nouveau format)
      // PRIORITÉ 2: Reconstruire depuis pollSuggestion (ancien format, rétrocompatibilité)
      metadata: msg.metadata
        ? msg.metadata
        : msg.pollSuggestion
          ? {
              pollGenerated: true,
              ...msg.pollSuggestion,
            }
          : undefined,
    }),
    [],
  );

  // Create new conversation
  const createConversation = useCallback(
    async (firstMessage: AutoSaveMessage): Promise<Conversation> => {
      log("Creating new conversation");

      try {
        const result = ConversationStorage.createConversation({
          title:
            firstMessage.content.slice(0, 50) +
            (firstMessage.content.length > 50 ? "..." : ""),
          firstMessage: firstMessage.content,
          userId: user?.id || "guest",
        });
        currentConversationRef.current = result;
        setConversationId(result.id);
        log("Conversation created", { id: result.id, title: result.title });
        return result;
      } catch (error) {
        log("Error creating conversation", { error });
        throw error;
      }
    },
    [user?.id, log],
  );

  // Title generation with debounce
  const triggerTitleGeneration = useCallback(
    (conversationId: string, messages: ConversationMessage[]) => {
      // Clear existing timeout
      if (titleGenerationTimeoutRef.current) {
        clearTimeout(titleGenerationTimeoutRef.current);
      }

      // Set new timeout for 1.5s debounce
      titleGenerationTimeoutRef.current = setTimeout(async () => {
        try {
          const conversation =
            ConversationStorage.getConversation(conversationId);
          if (!conversation) return;

          // Check if we should regenerate title
          // Consider title custom if it doesn't match auto-generated patterns
          const isAutoGeneratedTitle =
            conversation.title.startsWith("Conversation du") ||
            conversation.title.startsWith("New conversation") ||
            conversation.title.startsWith("Nouvelle conversation") ||
            conversation.title.length <= 50; // Auto-generated titles are typically short
          const hasCustomTitle = !isAutoGeneratedTitle;

          if (
            shouldRegenerateTitle(
              conversation.title,
              hasCustomTitle,
              messages.length,
            )
          ) {
            log("Generating new title", {
              conversationId,
              messageCount: messages.length,
            });

            const titleResult = generateConversationTitle(messages, {
              language: "fr",
            });
            if (titleResult.success) {
              // Update conversation with new title
              const updatedConversation = {
                ...conversation,
                title: titleResult.title,
                updatedAt: new Date(),
              };

              // Get all conversations, update the specific one, and save back
              const allConversations = ConversationStorage.getConversations();
              const updatedConversations = allConversations.map((conv) =>
                conv.id === conversationId ? updatedConversation : conv,
              );
              ConversationStorage.saveConversations(updatedConversations);

              log("Title updated", {
                conversationId,
                newTitle: titleResult.title,
              });
            }
          }
        } catch (error) {
          log("Error generating title", { conversationId, error });
        }
      }, 1500); // 1.5s debounce
    },
    [log],
  );

  // Add message and save immediately (simplified architecture)
  const addMessage = useCallback(
    async (message: AutoSaveMessage) => {
      log("Saving message immediately", { messageId: message.id });

      try {
        // Get current conversation ID
        let activeConversationId =
          currentConversationRef.current?.id || conversationId;

        // Create conversation if needed (for temp conversations)
        if (!activeConversationId || activeConversationId.startsWith("temp-")) {
          const conversation = await createConversation(message);
          activeConversationId = conversation.id;
        }

        // Convert and save this single message immediately
        const convertedMessage = convertMessage(message, activeConversationId);
        ConversationStorage.addMessages(activeConversationId, [
          convertedMessage,
        ]);

        // Verify it was saved
        const allMessages =
          ConversationStorage.getMessages(activeConversationId);
        setLastSaved(new Date());
        log("Message saved immediately", {
          messageId: message.id,
          totalMessages: allMessages.length,
        });

        // Trigger title generation with debounce (1.5s)
        triggerTitleGeneration(activeConversationId, allMessages);
      } catch (error) {
        logger.error(
          "Failed to save message immediately",
          "conversation",
          error,
        );
        log("Error saving message", { error, messageId: message.id });
      }
    },
    [
      log,
      conversationId,
      createConversation,
      convertMessage,
      triggerTitleGeneration,
    ],
  );

  // Resume conversation by ID
  const resumeConversation = useCallback(
    async (id: string): Promise<Conversation | null> => {
      log("Attempting to resume conversation", { id });

      try {
        // Add small delay to ensure localStorage is synchronized
        await new Promise((resolve) => setTimeout(resolve, 100));

        // Use ConversationStorage directly

        const conversation = ConversationStorage.getConversation(id);

        if (conversation) {
          setConversationId(id);
          setLastSaved(new Date());
          currentConversationRef.current = conversation;

          // Conversation resumed successfully
          return conversation;
        } else {
          return null;
        }
      } catch (error) {
        log("Error resuming conversation", { conversationId: id, error });
        throw error;
      }
    },
    [conversationId, log],
  );

  // Get current conversation with messages
  const getCurrentConversation = useCallback(async (): Promise<{
    conversation: Conversation;
    messages: ConversationMessage[];
  } | null> => {
    if (!conversationId) return null;

    try {
      return ConversationStorage.getConversationWithMessages(conversationId);
    } catch (error) {
      log("Error getting current conversation", { conversationId, error });
      return null;
    }
  }, [conversationId, log]);

  // Clear current conversation
  const clearConversation = useCallback(() => {
    log("Clearing conversation");

    setConversationId(null);
    setLastSaved(null);
    currentConversationRef.current = null;
  }, [log]);

  // Start new conversation (lazy - only sets up state, actual creation happens on first message)
  const startNewConversation = useCallback(async (): Promise<string> => {
    log("Starting new conversation session");

    const tempId = `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    setConversationId(tempId);
    setLastSaved(new Date());

    log("New conversation session ready", { tempId });
    return tempId;
  }, [log, conversationId]);

  // Get real conversation ID (non-temporary)
  const getRealConversationId = useCallback((): string | null => {
    if (!conversationId || conversationId.startsWith("temp-")) {
      return currentConversationRef.current?.id || null;
    }
    return conversationId;
  }, [conversationId]);

  return {
    conversationId,
    isAutoSaving,
    lastSaved,
    addMessage,
    startNewConversation,
    resumeConversation,
    getCurrentConversation,
    clearConversation,
    getRealConversationId,
  };
}
